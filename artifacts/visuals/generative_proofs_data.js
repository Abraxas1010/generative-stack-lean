window.GENERATIVE_PROOFS = {"meta": {"generatedAt": "2025-01-09", "source": "HeytingLean/GenerativeStack", "notes": "UMAP embedding of Generative Stack declarations"}, "items": [{"id": "LoF/HeytingCore.lean:instHeytingOmega", "name": "instHeytingOmega", "kind": "instance", "path": "LoF/HeytingCore.lean", "line": 48, "family": "Other", "snippet": "instance instHeytingOmega : HeytingAlgebra (R.Omega) := inferInstance\n\n/-- The standard Heyting adjunction transferred to the fixed-point algebra. -/\nlemma heyting_adjunction (a b c : R.Omega) :\n    a \u2293 b \u2264 c \u2194 a \u2264 b \u21e8 c :=", "pos": {"x": 0.005379053298383951, "y": 0.9973588585853577}, "pos3": {"x": 0.6112959384918213, "y": 0.3756175637245178, "z": 0.6162092685699463}}, {"id": "LoF/HeytingCore.lean:heyting_adjunction", "name": "heyting_adjunction", "kind": "theorem", "path": "LoF/HeytingCore.lean", "line": 51, "family": "Other", "snippet": "lemma heyting_adjunction (a b c : R.Omega) :\n    a \u2293 b \u2264 c \u2194 a \u2264 b \u21e8 c :=\n  (le_himp_iff (a := a) (b := b) (c := c)).symm\n\n/-- Residuation restated in terms of the fixed-point Heyting structure. -/", "pos": {"x": 0.005133757367730141, "y": 0.997096836566925}, "pos3": {"x": 0.6114808320999146, "y": 0.37616947293281555, "z": 0.6185691356658936}}, {"id": "LoF/HeytingCore.lean:residuation", "name": "residuation", "kind": "theorem", "path": "LoF/HeytingCore.lean", "line": 56, "family": "Other", "snippet": "lemma residuation (a b c : R.Omega) :\n    c \u2264 a \u21e8 b \u2194 c \u2293 a \u2264 b :=\n  (heyting_adjunction (R := R) c a b).symm\n\n/-! #### Residuation simp helpers -/", "pos": {"x": 0.003543210681527853, "y": 0.9953986406326294}, "pos3": {"x": 0.6130571365356445, "y": 0.3730875849723816, "z": 0.6188797354698181}}, {"id": "LoF/HeytingCore.lean:double_neg", "name": "double_neg", "kind": "theorem", "path": "LoF/HeytingCore.lean", "line": 109, "family": "Other", "snippet": "lemma double_neg (a : R.Omega) :\n    a \u2264 ((a \u21e8 (\u22a5 : R.Omega)) \u21e8 (\u22a5 : R.Omega)) := by\n  have h\u2081 : (a \u21e8 (\u22a5 : R.Omega)) \u2264 a \u21e8 (\u22a5 : R.Omega) := le_rfl\n  have h\u2082 :\n      (a \u21e8 (\u22a5 : R.Omega)) \u2293 a \u2264 (\u22a5 : R.Omega) :=", "pos": {"x": 0.007628835272043943, "y": 0.9997601509094238}, "pos3": {"x": 0.6114356517791748, "y": 0.37191450595855713, "z": 0.6190730333328247}}, {"id": "LoF/HeytingCore.lean:inf_himp_le", "name": "inf_himp_le", "kind": "theorem", "path": "LoF/HeytingCore.lean", "line": 126, "family": "Other", "snippet": "lemma inf_himp_le (a b : R.Omega) : a \u2293 (a \u21e8 b) \u2264 b := by\n  -- Using `inf_le_iff_le_himp` with `t := a \u21e8 b`, `u := a`, `v := b`.\n  have : (a \u21e8 b) \u2264 a \u21e8 b := le_rfl\n  -- Convert to `(a \u21e8 b) \u2293 a \u2264 b` then swap by commutativity of inf.\n  have h := (inf_le_iff_le_himp (R := R)", "pos": {"x": 0.0031273644417524338, "y": 0.9949527382850647}, "pos3": {"x": 0.6113032102584839, "y": 0.37694215774536133, "z": 0.6140204071998596}}, {"id": "LoF/HeytingCore.lean:booleanEquiv", "name": "booleanEquiv", "kind": "def", "path": "LoF/HeytingCore.lean", "line": 144, "family": "Other", "snippet": "def booleanEquiv (h : \u2200 a : \u03b1, R a = a) : R.Omega \u2243 \u03b1 where\n  toFun := Subtype.val\n  invFun := fun a => Omega.mk (R := R) a (h a)\n  left_inv := by\n    intro a", "pos": {"x": 0.006553287152200937, "y": 0.9985578060150146}, "pos3": {"x": 0.6094996333122253, "y": 0.3763676583766937, "z": 0.6171719431877136}}, {"id": "LoF/HeytingCore.lean:boolean_limit", "name": "boolean_limit", "kind": "theorem", "path": "LoF/HeytingCore.lean", "line": 165, "family": "Other", "snippet": "lemma boolean_limit (h : \u2200 a : \u03b1, R a = a) (a : \u03b1) :\n    R ((booleanEquiv (R := R) h).symm a : R.Omega) = a := by\n  have hx : R a = a := h a\n  dsimp [booleanEquiv]\n  change R ((Omega.mk (R := R) a hx : R.Omega) : \u03b1) = a", "pos": {"x": 0.007848919369280338, "y": 1.0}, "pos3": {"x": 0.6124891042709351, "y": 0.37691131234169006, "z": 0.6161524653434753}}, {"id": "LoF/Nucleus.lean:Reentry", "name": "Reentry", "kind": "structure", "path": "LoF/Nucleus.lean", "line": 12, "family": "Other", "snippet": "structure Reentry (\u03b1 : Type u) [PrimaryAlgebra \u03b1] where\n  nucleus : Nucleus \u03b1\n  primordial : \u03b1\n  counter : \u03b1\n  /-- Optional \u201csupport window\u201d used by some classical fragments. This", "pos": {"x": 0.277213454246521, "y": 0.014823684468865395}, "pos3": {"x": 0.37808534502983093, "y": 0.9882453680038452, "z": 0.4940902292728424}}, {"id": "LoF/Nucleus.lean:map_sup", "name": "map_sup", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 59, "family": "Other", "snippet": "lemma map_sup (R : Reentry \u03b1) (a b : \u03b1) :\n    R (a \u2294 b) = R ((R a) \u2294 (R b)) := by\n  classical\n  simpa [Reentry.coe_nucleus] using\n    (R.nucleus.toClosureOperator.closure_sup_closure (x := a) (y := b)).symm", "pos": {"x": 0.2713683247566223, "y": 0.01492114644497633}, "pos3": {"x": 0.38435906171798706, "y": 0.9932939410209656, "z": 0.49712979793548584}}, {"id": "LoF/Nucleus.lean:map_sup_le", "name": "map_sup_le", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 66, "family": "Other", "snippet": "lemma map_sup_le (R : Reentry \u03b1) (a b : \u03b1) :\n    R a \u2294 R b \u2264 R (a \u2294 b) := by\n  classical\n  exact R.nucleus.toClosureOperator.closure_sup_closure_le (x := a) (y := b)\n", "pos": {"x": 0.27982789278030396, "y": 0.015177368186414242}, "pos3": {"x": 0.3892855644226074, "y": 0.9871851801872253, "z": 0.49778512120246887}}, {"id": "LoF/Nucleus.lean:map_himp_le", "name": "map_himp_le", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 72, "family": "Other", "snippet": "lemma map_himp_le (R : Reentry \u03b1) (a b : \u03b1) :\n    R (a \u21e8 b) \u2264 a \u21e8 R b := by\n  simpa [Reentry.coe_nucleus] using\n    R.nucleus.map_himp_le (x := a) (y := b)\n", "pos": {"x": 0.2813129127025604, "y": 0.018025105819106102}, "pos3": {"x": 0.38421890139579773, "y": 0.9940230846405029, "z": 0.4977666437625885}}, {"id": "LoF/Nucleus.lean:Omega", "name": "Omega", "kind": "abbrev", "path": "LoF/Nucleus.lean", "line": 109, "family": "Other", "snippet": "abbrev Omega (R : Reentry \u03b1) : Type u := R.nucleus.toSublocale\n\n@[simp] lemma primordial_apply (R : Reentry \u03b1) :\n    R R.primordial = R.primordial :=\n  R.primordial_mem", "pos": {"x": 0.2847192883491516, "y": 0.014080196619033813}, "pos3": {"x": 0.3813062608242035, "y": 0.9921087622642517, "z": 0.4907742142677307}}, {"id": "LoF/Nucleus.lean:primordial_le_of_fixed", "name": "primordial_le_of_fixed", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 119, "family": "Other", "snippet": "lemma primordial_le_of_fixed (R : Reentry \u03b1) {x : \u03b1}\n    (hx_fix : R x = x) (hx_pos : \u22a5 < x) (hx_support : x \u2264 R.support) :\n    R.primordial \u2264 x :=\n  R.primordial_minimal hx_fix hx_pos hx_support\n", "pos": {"x": 0.27632686495780945, "y": 0.014305724762380123}, "pos3": {"x": 0.3854556381702423, "y": 0.9902247786521912, "z": 0.4900541603565216}}, {"id": "LoF/Nucleus.lean:mk", "name": "mk", "kind": "def", "path": "LoF/Nucleus.lean", "line": 129, "family": "Other", "snippet": "def mk (a : \u03b1) (h : R a = a) :\n    R.Omega := \u27e8a, \u27e8a, h\u27e9\u27e9\n\n@[simp] lemma coe_mk (a : \u03b1) (h : R a = a) :\n    ((Omega.mk (R := R) a h : R.Omega) : \u03b1) = a := rfl", "pos": {"x": 0.27560165524482727, "y": 0.01426418125629425}, "pos3": {"x": 0.3807767927646637, "y": 0.9902503490447998, "z": 0.4915536046028137}}, {"id": "LoF/Nucleus.lean:process", "name": "process", "kind": "def", "path": "LoF/Nucleus.lean", "line": 148, "family": "Other", "snippet": "def process (R : Reentry \u03b1) : R.Omega :=\n  Omega.mk (R := R) R.primordial R.primordial_mem\n\n/-- The complementary fixed point capturing the counter-process. -/\ndef counterProcess (R : Reentry \u03b1) : R.Omega :=", "pos": {"x": 0.2756274342536926, "y": 0.010103553533554077}, "pos3": {"x": 0.3844425082206726, "y": 0.987166702747345, "z": 0.48637622594833374}}, {"id": "LoF/Nucleus.lean:counterProcess", "name": "counterProcess", "kind": "def", "path": "LoF/Nucleus.lean", "line": 152, "family": "Other", "snippet": "def counterProcess (R : Reentry \u03b1) : R.Omega :=\n  Omega.mk (R := R) R.counter R.counter_mem\n\n@[simp] lemma process_coe (R : Reentry \u03b1) :\n    ((R.process : R.Omega) : \u03b1) = R.primordial := rfl", "pos": {"x": 0.2817334234714508, "y": 0.009228157810866833}, "pos3": {"x": 0.3888455331325531, "y": 0.9854093790054321, "z": 0.4905993938446045}}, {"id": "LoF/Nucleus.lean:process_inf_counter", "name": "process_inf_counter", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 162, "family": "Other", "snippet": "lemma process_inf_counter (R : Reentry \u03b1) :\n    R.process \u2293 R.counterProcess = \u22a5 := by\n  have h_le : R.process \u2293 R.counterProcess \u2264 \u22a5 := by\n    change ((R.process \u2293 R.counterProcess : R.Omega) : \u03b1)\n        \u2264 ((\u22a5 : R.Omega) : \u03b1)", "pos": {"x": 0.2836117148399353, "y": 0.009905600920319557}, "pos3": {"x": 0.3880353569984436, "y": 0.9918428659439087, "z": 0.49396055936813354}}, {"id": "LoF/Nucleus.lean:process_pos", "name": "process_pos", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 171, "family": "Other", "snippet": "lemma process_pos (R : Reentry \u03b1) : \u22a5 < ((R.process : R.Omega) : \u03b1) := by\n  change \u22a5 < R.primordial\n  exact R.primordial_nonbot\n\n/-- The primordial process lies inside the designated support window. -/", "pos": {"x": 0.2760206162929535, "y": 0.009190366603434086}, "pos3": {"x": 0.38067424297332764, "y": 0.9870480895042419, "z": 0.4956603944301605}}, {"id": "LoF/Nucleus.lean:process_in_support", "name": "process_in_support", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 176, "family": "Other", "snippet": "lemma process_in_support (R : Reentry \u03b1) :\n    ((R.process : R.Omega) : \u03b1) \u2264 R.support := by\n  -- This is just the `primordial_in_support` field transported to `\u03a9_R`.\n  simpa [process_coe] using R.primordial_in_support\n", "pos": {"x": 0.2821088433265686, "y": 0.017659395933151245}, "pos3": {"x": 0.3806610107421875, "y": 0.992172360420227, "z": 0.4949474036693573}}, {"id": "LoF/Nucleus.lean:counter_pos", "name": "counter_pos", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 182, "family": "Other", "snippet": "lemma counter_pos (R : Reentry \u03b1) : \u22a5 < ((R.counterProcess : R.Omega) : \u03b1) := by\n  change \u22a5 < R.counter\n  exact R.counter_nonbot\n\n/-- Package the complementary fixed points generated by re-entry. -/", "pos": {"x": 0.28472602367401123, "y": 0.016368068754673004}, "pos3": {"x": 0.3849121928215027, "y": 0.9911680817604065, "z": 0.4928799271583557}}, {"id": "LoF/Nucleus.lean:complementaryPair", "name": "complementaryPair", "kind": "def", "path": "LoF/Nucleus.lean", "line": 187, "family": "Other", "snippet": "def complementaryPair (R : Reentry \u03b1) : R.Omega \u00d7 R.Omega :=\n  \u27e8R.process, R.counterProcess\u27e9\n\n@[simp] lemma complementaryPair_fst (R : Reentry \u03b1) :\n    (R.complementaryPair.fst : \u03b1) = R.primordial := rfl", "pos": {"x": 0.2836771607398987, "y": 0.016379686072468758}, "pos3": {"x": 0.3772472143173218, "y": 0.9972860813140869, "z": 0.49521639943122864}}, {"id": "LoF/Nucleus.lean:boundaryCandidates", "name": "boundaryCandidates", "kind": "def", "path": "LoF/Nucleus.lean", "line": 202, "family": "Other", "snippet": "def boundaryCandidates (R : Reentry \u03b1) : Set (R.Omega) :=\n  {x | \u22a5 < (x : \u03b1) \u2227 (x : \u03b1) \u2264 R.support}\n\n@[simp] lemma mem_boundaryCandidates (R : Reentry \u03b1) (x : R.Omega) :\n    x \u2208 R.boundaryCandidates \u2194", "pos": {"x": 0.28840920329093933, "y": 0.011602327227592468}, "pos3": {"x": 0.3875487148761749, "y": 0.9866562485694885, "z": 0.4893645942211151}}, {"id": "LoF/Nucleus.lean:process_mem_boundaryCandidates", "name": "process_mem_boundaryCandidates", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 210, "family": "Other", "snippet": "lemma process_mem_boundaryCandidates (R : Reentry \u03b1) :\n    R.process \u2208 R.boundaryCandidates := by\n  constructor\n  \u00b7 -- positivity\n    simpa [process_coe, boundaryCandidates] using R.process_pos", "pos": {"x": 0.2794259786605835, "y": 0.00941268540918827}, "pos3": {"x": 0.3861784040927887, "y": 0.9959877133369446, "z": 0.49508997797966003}}, {"id": "LoF/Nucleus.lean:eulerBoundary_def", "name": "eulerBoundary_def", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 224, "family": "Other", "snippet": "lemma eulerBoundary_def (R : Reentry \u03b1) :\n    R.eulerBoundary = sInf (R.boundaryCandidates) := rfl\n\n/-- Any boundary candidate dominates the Euler boundary. -/\nlemma eulerBoundary_le_of_candidate (R : Reentry \u03b1) {x : R.Omega}", "pos": {"x": 0.277282178401947, "y": 0.011884813196957111}, "pos3": {"x": 0.384835809469223, "y": 0.9861569404602051, "z": 0.49613142013549805}}, {"id": "LoF/Nucleus.lean:eulerBoundary_le_of_candidate", "name": "eulerBoundary_le_of_candidate", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 228, "family": "Other", "snippet": "lemma eulerBoundary_le_of_candidate (R : Reentry \u03b1) {x : R.Omega}\n    (hx : x \u2208 R.boundaryCandidates) : R.eulerBoundary \u2264 x := by\n  simpa [eulerBoundary_def] using sInf_le (a := x) hx\n\n/-- A lower bound of boundary candidates lies below the Euler boundary. -/", "pos": {"x": 0.28545093536376953, "y": 0.005233523901551962}, "pos3": {"x": 0.38986968994140625, "y": 0.9967843294143677, "z": 0.4922082722187042}}, {"id": "LoF/Nucleus.lean:le_of_lower_bound", "name": "le_of_lower_bound", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 233, "family": "Other", "snippet": "lemma le_of_lower_bound (R : Reentry \u03b1) {a : R.Omega}\n    (h : \u2200 \u2983x\u2984, x \u2208 R.boundaryCandidates \u2192 a \u2264 x) :\n    a \u2264 R.eulerBoundary := by\n  classical\n  refine le_sInf ?_", "pos": {"x": 0.2907511591911316, "y": 0.011645588092505932}, "pos3": {"x": 0.382592111825943, "y": 0.9835798144340515, "z": 0.49932798743247986}}, {"id": "LoF/Nucleus.lean:eulerBoundary_le_process", "name": "eulerBoundary_le_process", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 242, "family": "Other", "snippet": "lemma eulerBoundary_le_process (R : Reentry \u03b1) :\n    R.eulerBoundary \u2264 R.process :=\n  eulerBoundary_le_of_candidate (R := R) (x := R.process)\n    (R.process_mem_boundaryCandidates)\n", "pos": {"x": 0.2850808799266815, "y": 0.005731502547860146}, "pos3": {"x": 0.3812132775783539, "y": 0.9974644184112549, "z": 0.4926997721195221}}, {"id": "LoF/Nucleus.lean:process_le_of_candidate", "name": "process_le_of_candidate", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 248, "family": "Other", "snippet": "lemma process_le_of_candidate (R : Reentry \u03b1) {x : R.Omega}\n    (hx : x \u2208 R.boundaryCandidates) :\n    R.process \u2264 x := by\n  -- Unpack the candidate conditions.\n  rcases hx with \u27e8hx_pos, hx_sup\u27e9", "pos": {"x": 0.2876356542110443, "y": 0.004276306834071875}, "pos3": {"x": 0.3848818242549896, "y": 0.9855000972747803, "z": 0.4965917766094208}}, {"id": "LoF/Nucleus.lean:process_le_eulerBoundary", "name": "process_le_eulerBoundary", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 259, "family": "Other", "snippet": "lemma process_le_eulerBoundary (R : Reentry \u03b1) :\n    R.process \u2264 R.eulerBoundary := by\n  refine R.le_of_lower_bound ?_\n  intro x hx\n  exact process_le_of_candidate (R := R) hx", "pos": {"x": 0.28414589166641235, "y": 0.0046180118806660175}, "pos3": {"x": 0.3798588812351227, "y": 0.9847609400749207, "z": 0.48652946949005127}}, {"id": "LoF/Nucleus.lean:eulerBoundary_pos", "name": "eulerBoundary_pos", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 276, "family": "Other", "snippet": "lemma eulerBoundary_pos (R : Reentry \u03b1) :\n    \u22a5 < ((R.eulerBoundary : R.Omega) : \u03b1) := by\n  simpa [eulerBoundary_eq_process] using (process_pos (R := R))\n\n/-- Consequently, the Euler boundary belongs to the candidate set. -/", "pos": {"x": 0.27272307872772217, "y": 0.01643085852265358}, "pos3": {"x": 0.381911963224411, "y": 0.9901851415634155, "z": 0.4851985573768616}}, {"id": "LoF/Nucleus.lean:eulerBoundary_mem_candidates", "name": "eulerBoundary_mem_candidates", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 281, "family": "Other", "snippet": "lemma eulerBoundary_mem_candidates (R : Reentry \u03b1) :\n    R.eulerBoundary \u2208 R.boundaryCandidates := by\n  -- Positivity and support membership for `eulerBoundary` follow from the\n  -- corresponding properties of `process` together with\n  -- `eulerBoundary_le_process`.", "pos": {"x": 0.2789554297924042, "y": 0.010107803158462048}, "pos3": {"x": 0.3903254270553589, "y": 0.9891683459281921, "z": 0.49923086166381836}}, {"id": "LoF/Nucleus.lean:eulerBoundary_isLeast", "name": "eulerBoundary_isLeast", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 303, "family": "Other", "snippet": "lemma eulerBoundary_isLeast (R : Reentry \u03b1) :\n    IsLeast (R.boundaryCandidates) (R.eulerBoundary) := by\n  refine \u27e8R.eulerBoundary_mem_candidates, ?_\u27e9\n  intro x hx\n  exact R.eulerBoundary_le_of_candidate hx", "pos": {"x": 0.2794882655143738, "y": 0.02347312681376934}, "pos3": {"x": 0.38952216506004333, "y": 0.9826899766921997, "z": 0.4920346140861511}}, {"id": "LoF/Nucleus.lean:eulerBoundary_in_support", "name": "eulerBoundary_in_support", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 310, "family": "Other", "snippet": "lemma eulerBoundary_in_support (R : Reentry \u03b1) :\n    ((R.eulerBoundary : R.Omega) : \u03b1) \u2264 R.support := by\n  -- Unpack the support component from membership in `boundaryCandidates`.\n  have h :=\n    (R.mem_boundaryCandidates (x := R.eulerBoundary)).1", "pos": {"x": 0.285361111164093, "y": 0.02467241697013378}, "pos3": {"x": 0.3867403566837311, "y": 0.998954176902771, "z": 0.4882242679595947}}, {"id": "LoF/Nucleus.lean:eulerBoundary_minimal_nontrivial", "name": "eulerBoundary_minimal_nontrivial", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 322, "family": "Other", "snippet": "lemma eulerBoundary_minimal_nontrivial (R : Reentry \u03b1) :\n    \u22a5 < ((R.eulerBoundary : R.Omega) : \u03b1) \u2227\n    R (((R.eulerBoundary : R.Omega) : \u03b1)) =\n      ((R.eulerBoundary : R.Omega) : \u03b1) \u2227\n    \u2200 {y : R.Omega},", "pos": {"x": 0.2781028151512146, "y": 0.02156994864344597}, "pos3": {"x": 0.39176392555236816, "y": 0.9936474561691284, "z": 0.49598509073257446}}, {"id": "LoF/Nucleus.lean:eulerBoundary_le_counter", "name": "eulerBoundary_le_counter", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 347, "family": "Other", "snippet": "lemma eulerBoundary_le_counter (R : Reentry \u03b1)\n    (hcounter_sup : (R.counter : \u03b1) \u2264 R.support) :\n    R.eulerBoundary \u2264 R.counterProcess := by\n  -- First show that the counter-process is itself a boundary candidate.\n  have hcand : R.counterProcess \u2208 R.boundaryCandidates := by", "pos": {"x": 0.2761669158935547, "y": 0.004265548195689917}, "pos3": {"x": 0.3823099434375763, "y": 0.9887722730636597, "z": 0.5017754435539246}}, {"id": "LoF/Nucleus.lean:eulerBoundary_complementary", "name": "eulerBoundary_complementary", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 366, "family": "Other", "snippet": "lemma eulerBoundary_complementary (R : Reentry \u03b1) :\n    R.eulerBoundary \u2293 R.counterProcess = \u22a5 := by\n  calc\n    R.eulerBoundary \u2293 R.counterProcess\n        = R.process \u2293 R.counterProcess := by", "pos": {"x": 0.283496618270874, "y": 0.004843268543481827}, "pos3": {"x": 0.38631802797317505, "y": 0.9834824204444885, "z": 0.4912451505661011}}, {"id": "LoF/Nucleus.lean:eulerBoundary_unique_minimal", "name": "eulerBoundary_unique_minimal", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 378, "family": "Other", "snippet": "lemma eulerBoundary_unique_minimal (R : Reentry \u03b1) (x : R.Omega)\n    (hx_nontrivial : \u22a5 < (x : \u03b1))\n    (hx_support : (x : \u03b1) \u2264 R.support)\n    (hx_min : \u2200 y : R.Omega, \u22a5 < (y : \u03b1) \u2192 (x : \u03b1) \u2264 (y : \u03b1)) :\n    x = R.eulerBoundary := by", "pos": {"x": 0.27051448822021484, "y": 0.010085923597216606}, "pos3": {"x": 0.38944318890571594, "y": 1.0, "z": 0.4966581165790558}}, {"id": "LoF/Nucleus.lean:eulerBoundary_unique_minimal_support", "name": "eulerBoundary_unique_minimal_support", "kind": "theorem", "path": "LoF/Nucleus.lean", "line": 407, "family": "Other", "snippet": "lemma eulerBoundary_unique_minimal_support (R : Reentry \u03b1) (x : R.Omega)\n    (hx_nontrivial : \u22a5 < (x : \u03b1))\n    (hx_support : (x : \u03b1) \u2264 R.support)\n    (hx_min :\n      \u2200 y : R.Omega, \u22a5 < (y : \u03b1) \u2192 (y : \u03b1) \u2264 R.support \u2192", "pos": {"x": 0.2818453013896942, "y": 0.0}, "pos3": {"x": 0.3757510781288147, "y": 0.9883301854133606, "z": 0.4918106496334076}}, {"id": "LoF/PrimaryAlgebra.lean:PrimaryAlgebra", "name": "PrimaryAlgebra", "kind": "structure", "path": "LoF/PrimaryAlgebra.lean", "line": 10, "family": "LoF", "snippet": "class PrimaryAlgebra (\u03b1 : Type u) extends Order.Frame \u03b1\n\nend LoF\nend HeytingLean\n", "pos": {"x": 0.47831612825393677, "y": 0.24255459010601044}, "pos3": {"x": 0.5511448383331299, "y": 0.3715904653072357, "z": 0.4058273434638977}}, {"id": "LoF/BoundaryHeyting.lean:boundary_isLeast", "name": "boundary_isLeast", "kind": "theorem", "path": "LoF/BoundaryHeyting.lean", "line": 39, "family": "Other", "snippet": "theorem boundary_isLeast (R : Reentry \u03b1) : IsLeast (R.boundaryCandidates) (boundary (R := R)) := by\n  simpa [boundary] using R.eulerBoundary_isLeast\n\n/-- The Heyting structure on `\u03a9_R` (fixed points) is canonical. -/\ninstance (R : Reentry \u03b1) : HeytingAlgebra (R.Omega) := inferInstance", "pos": {"x": 0.2892463207244873, "y": 0.020940108224749565}, "pos3": {"x": 0.39140990376472473, "y": 0.9963368773460388, "z": 0.4873468577861786}}, {"id": "LoF/BoundaryHeyting.lean:boundary_modusPonens", "name": "boundary_modusPonens", "kind": "theorem", "path": "LoF/BoundaryHeyting.lean", "line": 46, "family": "Other", "snippet": "theorem boundary_modusPonens (R : Reentry \u03b1) (a b : R.Omega) : a \u2293 (a \u21e8 b) \u2264 b := by\n  exact Reentry.inf_himp_le (R := R) a b\n\nend BoundaryHeyting\n", "pos": {"x": 0.2884405851364136, "y": 0.013113622553646564}, "pos3": {"x": 0.38718751072883606, "y": 0.9952977299690247, "z": 0.4848613440990448}}, {"id": "LoF/OmegaCategory.lean:where", "name": "where", "kind": "structure", "path": "LoF/OmegaCategory.lean", "line": 20, "family": "Other", "snippet": "  structure where tensor is meet and unit is `\u22a4`.\n\nIn this file we:\n\n* install the `CartesianMonoidalCategory` structure on `R.Omega`;", "pos": {"x": 0.0022827479988336563, "y": 0.9940419793128967}, "pos3": {"x": 0.6100995540618896, "y": 0.37268805503845215, "z": 0.6184803247451782}}, {"id": "LoF/OmegaCategory.lean:ihom", "name": "ihom", "kind": "def", "path": "LoF/OmegaCategory.lean", "line": 54, "family": "Other", "snippet": "def ihom (a b : R.Omega) : R.Omega :=\n  a \u21e8 b\n\n/-- Residuation for the internal hom on `\u03a9_R`. -/\nlemma le_ihom_iff (a b c : R.Omega) :", "pos": {"x": 0.0020107149612158537, "y": 0.9937501549720764}, "pos3": {"x": 0.6136294603347778, "y": 0.37906989455223083, "z": 0.6149213910102844}}, {"id": "LoF/OmegaCategory.lean:le_ihom_iff", "name": "le_ihom_iff", "kind": "theorem", "path": "LoF/OmegaCategory.lean", "line": 58, "family": "Other", "snippet": "lemma le_ihom_iff (a b c : R.Omega) :\n    c \u2264 ihom R a b \u2194 c \u2293 a \u2264 b := by\n  -- This is just `Reentry.residuation` specialized and rewritten.\n  change c \u2264 a \u21e8 b \u2194 c \u2293 a \u2264 b\n  exact", "pos": {"x": 0.0, "y": 0.991602897644043}, "pos3": {"x": 0.6090908646583557, "y": 0.3771169185638428, "z": 0.6193324327468872}}, {"id": "LoF/OmegaCategory.lean:ihomOrderHom", "name": "ihomOrderHom", "kind": "def", "path": "LoF/OmegaCategory.lean", "line": 66, "family": "Other", "snippet": "def ihomOrderHom (a : R.Omega) : R.Omega \u2192o R.Omega where\n  toFun b := a \u21e8 b\n  monotone' := by\n    intro x y hxy\n    -- We show `a \u21e8 x \u2264 a \u21e8 y` using Heyting residuation and `inf_himp_le`.", "pos": {"x": 0.0013367760693654418, "y": 0.993030309677124}, "pos3": {"x": 0.6091932058334351, "y": 0.37394124269485474, "z": 0.6180009245872498}}, {"id": "LoF/OmegaCategory.lean:ihomFunctor", "name": "ihomFunctor", "kind": "def", "path": "LoF/OmegaCategory.lean", "line": 83, "family": "Other", "snippet": "def ihomFunctor (a : R.Omega) : R.Omega \u2964 R.Omega :=\n  (ihomOrderHom (R := R) a).toFunctor\n\nend ClosedStructure\n", "pos": {"x": 0.003965709358453751, "y": 0.9958382248878479}, "pos3": {"x": 0.6086201071739197, "y": 0.37291574478149414, "z": 0.6151065230369568}}, {"id": "LoF/Combinators/Denotational.lean:SKYModel", "name": "SKYModel", "kind": "structure", "path": "LoF/Combinators/Denotational.lean", "line": 36, "family": "Combinator", "snippet": "structure SKYModel (\u03b1 : Type u) where\n  app : \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  K : \u03b1\n  S : \u03b1\n  Y : \u03b1", "pos": {"x": 0.5967023372650146, "y": 0.6726676821708679}, "pos3": {"x": 0.2960135340690613, "y": 0.5410341620445251, "z": 0.9390640258789062}}, {"id": "LoF/Combinators/Denotational.lean:denote", "name": "denote", "kind": "def", "path": "LoF/Combinators/Denotational.lean", "line": 49, "family": "Other", "snippet": "def denote (M : SKYModel \u03b1) : Comb \u2192 \u03b1\n  | .K => M.K\n  | .S => M.S\n  | .Y => M.Y\n  | .app f a => M.app (denote M f) (denote M a)", "pos": {"x": 0.5918781161308289, "y": 0.6764113306999207}, "pos3": {"x": 0.2977847456932068, "y": 0.5394932627677917, "z": 0.9337638020515442}}, {"id": "LoF/Combinators/Denotational.lean:denote_step", "name": "denote_step", "kind": "theorem", "path": "LoF/Combinators/Denotational.lean", "line": 61, "family": "Other", "snippet": "theorem denote_step (M : SKYModel \u03b1) {t u : Comb} (h : Comb.Step t u) :\n    denote M t = denote M u := by\n  induction h with\n  | K_rule x y =>\n      simp [denote]", "pos": {"x": 0.594028890132904, "y": 0.675925076007843}, "pos3": {"x": 0.30164021253585815, "y": 0.5374017953872681, "z": 0.9371757507324219}}, {"id": "LoF/Combinators/Denotational.lean:denote_steps", "name": "denote_steps", "kind": "theorem", "path": "LoF/Combinators/Denotational.lean", "line": 78, "family": "Other", "snippet": "theorem denote_steps (M : SKYModel \u03b1) {t u : Comb} (h : Comb.Steps t u) :\n    denote M t = denote M u := by\n  induction h with\n  | refl t => rfl\n  | trans hstep _ ih =>", "pos": {"x": 0.5971606969833374, "y": 0.6731163859367371}, "pos3": {"x": 0.29897889494895935, "y": 0.5451160669326782, "z": 0.9361248016357422}}, {"id": "LoF/Combinators/Denotational.lean:ScottSKYModel", "name": "ScottSKYModel", "kind": "structure", "path": "LoF/Combinators/Denotational.lean", "line": 91, "family": "Combinator", "snippet": "structure ScottSKYModel (\u03b1 : Type u) [OmegaCompletePartialOrder \u03b1] [OrderBot \u03b1] where\n  D : ReflexiveDomain (\u03b1 := \u03b1)\n  K : \u03b1\n  S : \u03b1\n  Y : \u03b1", "pos": {"x": 0.5976442098617554, "y": 0.6707444190979004}, "pos3": {"x": 0.29810285568237305, "y": 0.542489767074585, "z": 0.9359341859817505}}, {"id": "LoF/Combinators/Denotational.lean:toSKYModel", "name": "toSKYModel", "kind": "def", "path": "LoF/Combinators/Denotational.lean", "line": 104, "family": "Combinator", "snippet": "def toSKYModel (M : ScottSKYModel \u03b1) : SKYModel \u03b1 where\n  app := fun f x => M.D.app f x\n  K := M.K\n  S := M.S\n  Y := M.Y", "pos": {"x": 0.5963069796562195, "y": 0.6763896346092224}, "pos3": {"x": 0.29971712827682495, "y": 0.5412164330482483, "z": 0.9313468933105469}}, {"id": "LoF/Combinators/Denotational.lean:denote_steps_sound", "name": "denote_steps_sound", "kind": "theorem", "path": "LoF/Combinators/Denotational.lean", "line": 113, "family": "Other", "snippet": "theorem denote_steps_sound (M : ScottSKYModel \u03b1) {t u : Comb} (h : Comb.Steps t u) :\n    SKYModel.denote (M.toSKYModel) t = SKYModel.denote (M.toSKYModel) u :=\n  SKYModel.denote_steps (M := M.toSKYModel) h\n\nend ScottSKYModel", "pos": {"x": 0.5957267880439758, "y": 0.6771152019500732}, "pos3": {"x": 0.29691269993782043, "y": 0.5430655479431152, "z": 0.9349638223648071}}, {"id": "LoF/Combinators/SKY.lean:Steps", "name": "Steps", "kind": "theorem", "path": "LoF/Combinators/SKY.lean", "line": 46, "family": "Other", "snippet": "theorem Steps.of_eq {t u : Comb} (h : t = u) : Steps t u := by\n  subst h\n  exact Steps.refl _\n\n/-- A term is in normal form if it admits no `Step` successors. -/", "pos": {"x": 0.5796625018119812, "y": 0.6696362495422363}, "pos3": {"x": 0.2873228192329407, "y": 0.5298264622688293, "z": 0.9306644201278687}}, {"id": "LoF/Combinators/SKY.lean:Normal", "name": "Normal", "kind": "def", "path": "LoF/Combinators/SKY.lean", "line": 51, "family": "Other", "snippet": "def Normal (t : Comb) : Prop :=\n  \u2200 u : Comb, \u00ac Step t u\n\n/-- The combinator `K` is in normal form. -/\ntheorem K_normal : Normal Comb.K := by", "pos": {"x": 0.5831980109214783, "y": 0.6683902740478516}, "pos3": {"x": 0.28880348801612854, "y": 0.5305365324020386, "z": 0.9342844486236572}}, {"id": "LoF/Combinators/SKY.lean:K_normal", "name": "K_normal", "kind": "theorem", "path": "LoF/Combinators/SKY.lean", "line": 55, "family": "Other", "snippet": "theorem K_normal : Normal Comb.K := by\n  intro u h\n  cases h\n\n/-- The combinator `S` is in normal form. -/", "pos": {"x": 0.5878247022628784, "y": 0.6655112504959106}, "pos3": {"x": 0.2851085662841797, "y": 0.534641444683075, "z": 0.9339840412139893}}, {"id": "LoF/Combinators/SKY.lean:S_normal", "name": "S_normal", "kind": "theorem", "path": "LoF/Combinators/SKY.lean", "line": 60, "family": "Other", "snippet": "theorem S_normal : Normal Comb.S := by\n  intro u h\n  cases h\n\n/-- The combinator `Y` is in normal form. -/", "pos": {"x": 0.5797398686408997, "y": 0.6707902550697327}, "pos3": {"x": 0.28911304473876953, "y": 0.5325794219970703, "z": 0.9287217855453491}}, {"id": "LoF/Combinators/SKY.lean:Y_normal", "name": "Y_normal", "kind": "theorem", "path": "LoF/Combinators/SKY.lean", "line": 65, "family": "Other", "snippet": "theorem Y_normal : Normal Comb.Y := by\n  intro u h\n  cases h\n\n/-- The combinator `K \u00b7 S` is in normal form. -/", "pos": {"x": 0.5816287398338318, "y": 0.6675645112991333}, "pos3": {"x": 0.2890782654285431, "y": 0.5311532020568848, "z": 0.9279669523239136}}, {"id": "LoF/Combinators/SKY.lean:K_app_S_normal", "name": "K_app_S_normal", "kind": "theorem", "path": "LoF/Combinators/SKY.lean", "line": 70, "family": "Other", "snippet": "theorem K_app_S_normal : Normal (Comb.app Comb.K Comb.S) := by\n  intro u h\n  cases h with\n  | app_left h' =>\n      -- The function part would need to step, but `K` is normal.", "pos": {"x": 0.5780163407325745, "y": 0.6687989830970764}, "pos3": {"x": 0.28540802001953125, "y": 0.5343199968338013, "z": 0.9272103309631348}}, {"id": "LoF/Combinators/SKY.lean:I", "name": "I", "kind": "def", "path": "LoF/Combinators/SKY.lean", "line": 83, "family": "Other", "snippet": "def I : Comb := Comb.app (Comb.app .S .K) .K\n\n/-- One-step reduction from `I` applied to `t` to\n`(K` applied to `t)` applied again to `K` and `t`. -/\ntheorem I_step (t : Comb) :", "pos": {"x": 0.5789351463317871, "y": 0.6655420064926147}, "pos3": {"x": 0.2852286696434021, "y": 0.5289245843887329, "z": 0.9301170110702515}}, {"id": "LoF/Combinators/SKY.lean:I_step", "name": "I_step", "kind": "theorem", "path": "LoF/Combinators/SKY.lean", "line": 87, "family": "Other", "snippet": "theorem I_step (t : Comb) :\n  Step (Comb.app I t) (Comb.app (Comb.app .K t) (Comb.app .K t)) := by\n  -- This is an instance of the S-rule with `x = K`, `y = K`, `z = t`.\n  simpa [I] using\n    Step.S_rule (x := .K) (y := .K) (z := t)", "pos": {"x": 0.5765343904495239, "y": 0.6692494750022888}, "pos3": {"x": 0.28931739926338196, "y": 0.5252552628517151, "z": 0.9313095808029175}}, {"id": "LoF/Combinators/SKY.lean:K_app_app_step", "name": "K_app_app_step", "kind": "theorem", "path": "LoF/Combinators/SKY.lean", "line": 94, "family": "Other", "snippet": "theorem K_app_app_step (t : Comb) :\n  Step (Comb.app (Comb.app .K t) (Comb.app .K t)) t := by\n  -- Apply the K-rule with arguments `t` and `K \u00b7 t`.\n  simpa using Step.K_rule (x := t) (y := Comb.app .K t)\n", "pos": {"x": 0.5824457406997681, "y": 0.6713799238204956}, "pos3": {"x": 0.2842843234539032, "y": 0.5317239165306091, "z": 0.9313108921051025}}, {"id": "LoF/Combinators/SKY.lean:I_reduces", "name": "I_reduces", "kind": "theorem", "path": "LoF/Combinators/SKY.lean", "line": 101, "family": "Other", "snippet": "theorem I_reduces (t : Comb) : Steps (Comb.app I t) t := by\n  refine Steps.trans (t := Comb.app I t)\n    (u := Comb.app (Comb.app .K t) (Comb.app .K t))\n    (v := t) ?h\u2081 ?h\u2082\n  \u00b7 exact I_step t", "pos": {"x": 0.5810068845748901, "y": 0.6651978492736816}, "pos3": {"x": 0.2858157753944397, "y": 0.5342131853103638, "z": 0.9315442442893982}}, {"id": "LoF/Combinators/EigenformBridge.lean:Steps", "name": "Steps", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 43, "family": "Other", "snippet": "theorem Steps.app_left {f f' a : Comb} : Steps f f' \u2192 Steps (Comb.app f a) (Comb.app f' a) := by\n  intro h\n  induction h with\n  | refl t => exact Steps.refl (Comb.app t a)\n  | trans hstep hsteps ih =>", "pos": {"x": 0.5937082767486572, "y": 0.6674311757087708}, "pos3": {"x": 0.2936423420906067, "y": 0.5417658090591431, "z": 0.9404353499412537}}, {"id": "LoF/Combinators/EigenformBridge.lean:Steps", "name": "Steps", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 50, "family": "Other", "snippet": "theorem Steps.app_right {f a a' : Comb} : Steps a a' \u2192 Steps (Comb.app f a) (Comb.app f a') := by\n  intro h\n  induction h with\n  | refl t => exact Steps.refl (Comb.app f t)\n  | trans hstep hsteps ih =>", "pos": {"x": 0.5898911356925964, "y": 0.6651609539985657}, "pos3": {"x": 0.2915273904800415, "y": 0.5460270643234253, "z": 0.9378772377967834}}, {"id": "LoF/Combinators/EigenformBridge.lean:Y_step", "name": "Y_step", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 60, "family": "Other", "snippet": "theorem Y_step (f : Comb) :\n    Step (Comb.app .Y f) (Comb.app f (Comb.app .Y f)) := by\n  simpa using Step.Y_rule (f := f)\n\n/-- Multi-step Y-unfolding as an eigenform equation. -/", "pos": {"x": 0.587613582611084, "y": 0.6643441319465637}, "pos3": {"x": 0.29288366436958313, "y": 0.537560224533081, "z": 0.9368875622749329}}, {"id": "LoF/Combinators/EigenformBridge.lean:Y_eigenform", "name": "Y_eigenform", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 65, "family": "Other", "snippet": "theorem Y_eigenform (f : Comb) :\n    Steps (Comb.app .Y f) (Comb.app f (Comb.app .Y f)) := by\n  exact Steps.trans (Y_step f) (Steps.refl _)\n\n/-- Joinability statement: `Y f` and `f (Y f)` share a common reduct (namely `f (Y f)`). -/", "pos": {"x": 0.5885790586471558, "y": 0.671042263507843}, "pos3": {"x": 0.29547208547592163, "y": 0.533921480178833, "z": 0.9333784580230713}}, {"id": "LoF/Combinators/EigenformBridge.lean:Y_produces_fixedpoint", "name": "Y_produces_fixedpoint", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 70, "family": "Other", "snippet": "theorem Y_produces_fixedpoint (f : Comb) :\n    \u2203 t : Comb, Steps (Comb.app .Y f) t \u2227 Steps (Comb.app f (Comb.app .Y f)) t := by\n  refine \u27e8Comb.app f (Comb.app .Y f), ?_, ?_\u27e9\n  \u00b7 exact Y_eigenform f\n  \u00b7 exact Steps.refl _", "pos": {"x": 0.5880087614059448, "y": 0.6682005524635315}, "pos3": {"x": 0.29330918192863464, "y": 0.536893904209137, "z": 0.9310809969902039}}, {"id": "LoF/Combinators/EigenformBridge.lean:omega", "name": "omega", "kind": "def", "path": "LoF/Combinators/EigenformBridge.lean", "line": 79, "family": "Other", "snippet": "def omega : Comb :=\n  Comb.app (Comb.app .S Comb.I) Comb.I\n\n/-- `\u03c9 t \u2192* t t`. -/\ntheorem omega_selfApply (t : Comb) :", "pos": {"x": 0.5871777534484863, "y": 0.6731017231941223}, "pos3": {"x": 0.29084405303001404, "y": 0.5397182106971741, "z": 0.9312124848365784}}, {"id": "LoF/Combinators/EigenformBridge.lean:omega_selfApply", "name": "omega_selfApply", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 83, "family": "Other", "snippet": "theorem omega_selfApply (t : Comb) :\n    Steps (Comb.app omega t) (Comb.app t t) := by\n  -- `\u03c9 t = (S I I) t \u21a6 I t (I t) \u2192* t t`.\n  have h1 :\n      Step (Comb.app omega t) (Comb.app (Comb.app Comb.I t) (Comb.app Comb.I t)) := by", "pos": {"x": 0.5911484956741333, "y": 0.6728593111038208}, "pos3": {"x": 0.2949846088886261, "y": 0.5411674976348877, "z": 0.9375561475753784}}, {"id": "LoF/Combinators/EigenformBridge.lean:gremlin", "name": "gremlin", "kind": "def", "path": "LoF/Combinators/EigenformBridge.lean", "line": 101, "family": "Other", "snippet": "def gremlin (f : Comb) : Comb :=\n  Comb.app (Comb.app .S (Comb.app .K f)) omega\n\n/-- `G x \u2192* f (x x)` where `G := gremlin f`. -/\ntheorem gremlin_apply (f x : Comb) :", "pos": {"x": 0.593718409538269, "y": 0.6623633503913879}, "pos3": {"x": 0.29873138666152954, "y": 0.5352516770362854, "z": 0.941924512386322}}, {"id": "LoF/Combinators/EigenformBridge.lean:gremlin_apply", "name": "gremlin_apply", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 105, "family": "Other", "snippet": "theorem gremlin_apply (f x : Comb) :\n    Steps (Comb.app (gremlin f) x) (Comb.app f (Comb.app x x)) := by\n  -- `(S (K f) \u03c9) x \u21a6 (K f x) (\u03c9 x) \u21a6 f (\u03c9 x) \u2192* f (x x)`.\n  have hS :\n      Step (Comb.app (gremlin f) x)", "pos": {"x": 0.5889423489570618, "y": 0.6595898866653442}, "pos3": {"x": 0.28784605860710144, "y": 0.535984218120575, "z": 0.9410078525543213}}, {"id": "LoF/Combinators/EigenformBridge.lean:gremlin_fixedpoint", "name": "gremlin_fixedpoint", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 123, "family": "Other", "snippet": "theorem gremlin_fixedpoint (f : Comb) :\n    Steps (Comb.app (gremlin f) (gremlin f)) (Comb.app f (Comb.app (gremlin f) (gremlin f))) := by\n  -- `G G \u2192* f (G G)` is exactly `gremlin_apply f (gremlin f)` plus one \u03c9-step.\n  -- `gremlin_apply` gives `G G \u2192* f (G G)` already (since `x = G`).\n  simpa usin", "pos": {"x": 0.5831279158592224, "y": 0.6602705121040344}, "pos3": {"x": 0.2838079333305359, "y": 0.5383376479148865, "z": 0.9384117126464844}}, {"id": "LoF/Combinators/EigenformBridge.lean:scottFix_isFixed", "name": "scottFix_isFixed", "kind": "theorem", "path": "LoF/Combinators/EigenformBridge.lean", "line": 135, "family": "Other", "snippet": "theorem scottFix_isFixed' {\u03b1 : Type _} [OmegaCompletePartialOrder \u03b1] [OrderBot \u03b1] (f : \u03b1 \u2192\ud835\udc84 \u03b1) :\n    f (HeytingLean.LoF.Bauer.scottFix (\u03b1 := \u03b1) f) = HeytingLean.LoF.Bauer.scottFix (\u03b1 := \u03b1) f :=\n  HeytingLean.LoF.Bauer.scottFix_isFixed (\u03b1 := \u03b1) (f := f)\n\n/-!", "pos": {"x": 0.5919134616851807, "y": 0.6591278314590454}, "pos3": {"x": 0.2902700901031494, "y": 0.5378663539886475, "z": 0.9381685256958008}}, {"id": "LoF/HoTT/Identity.lean:Id", "name": "Id", "kind": "abbrev", "path": "LoF/HoTT/Identity.lean", "line": 25, "family": "Other", "snippet": "abbrev Id {\u03b1 : Type u} (x y : \u03b1) : Prop := x = y\n\nnotation:50 x \" \u27e1 \" y => Id x y\n\n/-! ### Specialization: identity for LoF propositions/forms -/", "pos": {"x": 0.4888423681259155, "y": 0.22191905975341797}, "pos3": {"x": 0.5450925230979919, "y": 0.35249415040016174, "z": 0.39670440554618835}}, {"id": "LoF/HoTT/Identity.lean:FormId", "name": "FormId", "kind": "abbrev", "path": "LoF/HoTT/Identity.lean", "line": 36, "family": "Other", "snippet": "abbrev FormId {Form : Type u} (P Q : Form) : Prop := Id P Q\n\nnotation:50 P \" \u2243\u209a \" Q => FormId P Q\n\nend FormId", "pos": {"x": 0.4905591905117035, "y": 0.22202730178833008}, "pos3": {"x": 0.5437986850738525, "y": 0.3519141972064972, "z": 0.3962499499320984}}, {"id": "LoF/HoTT/Identity.lean:Id", "name": "Id", "kind": "theorem", "path": "LoF/HoTT/Identity.lean", "line": 50, "family": "Other", "snippet": "theorem Id.refl {\u03b1 : Type u} (x : \u03b1) : Id x x := rfl\n\n/-- Symmetry of the identity relation. -/\ntheorem Id.symm {\u03b1 : Type u} {x y : \u03b1} : Id x y \u2192 Id y x := by\n  intro h", "pos": {"x": 0.49062761664390564, "y": 0.2207261174917221}, "pos3": {"x": 0.5439944863319397, "y": 0.35062941908836365, "z": 0.3949565589427948}}, {"id": "LoF/HoTT/Identity.lean:Id", "name": "Id", "kind": "theorem", "path": "LoF/HoTT/Identity.lean", "line": 53, "family": "Other", "snippet": "theorem Id.symm {\u03b1 : Type u} {x y : \u03b1} : Id x y \u2192 Id y x := by\n  intro h\n  exact Eq.symm h\n\n/-- Transitivity of the identity relation. -/", "pos": {"x": 0.4878997504711151, "y": 0.22152581810951233}, "pos3": {"x": 0.5455942749977112, "y": 0.35358554124832153, "z": 0.3973419964313507}}, {"id": "LoF/HoTT/Identity.lean:Id", "name": "Id", "kind": "theorem", "path": "LoF/HoTT/Identity.lean", "line": 58, "family": "Other", "snippet": "theorem Id.trans {\u03b1 : Type u} {x y z : \u03b1} :\n    Id x y \u2192 Id y z \u2192 Id x z := by\n  intro h\u2081 h\u2082\n  exact Eq.trans h\u2081 h\u2082\n", "pos": {"x": 0.49252018332481384, "y": 0.21899832785129547}, "pos3": {"x": 0.5475552678108215, "y": 0.3545513451099396, "z": 0.3949466347694397}}, {"id": "LoF/HoTT/Identity.lean:Id", "name": "Id", "kind": "def", "path": "LoF/HoTT/Identity.lean", "line": 66, "family": "Other", "snippet": "def Id.rec {\u03b1 : Type u} {x : \u03b1}\n    {P : \u03b1 \u2192 Prop} (h : P x) :\n    \u2200 {y}, Id x y \u2192 P y\n  | _, rfl => h\n", "pos": {"x": 0.49208590388298035, "y": 0.21878446638584137}, "pos3": {"x": 0.5431644320487976, "y": 0.3515051603317261, "z": 0.3964959979057312}}, {"id": "LoF/Bauer/Eigenforms.lean:joinConst", "name": "joinConst", "kind": "def", "path": "LoF/Bauer/Eigenforms.lean", "line": 36, "family": "Other", "snippet": "def joinConst (p : D) : D \u2192 D := fun x => x \u2294 p\n\nlemma joinConst_mono (p : D) : Monotone (joinConst (D := D) p) := by\n  intro a b hab\n  exact sup_le_sup_right hab p", "pos": {"x": 0.5047104358673096, "y": 0.9003550410270691}, "pos3": {"x": 0.4349921941757202, "y": 0.33114904165267944, "z": 0.004226222168654203}}, {"id": "LoF/Bauer/Eigenforms.lean:joinConst_mono", "name": "joinConst_mono", "kind": "theorem", "path": "LoF/Bauer/Eigenforms.lean", "line": 38, "family": "Other", "snippet": "lemma joinConst_mono (p : D) : Monotone (joinConst (D := D) p) := by\n  intro a b hab\n  exact sup_le_sup_right hab p\n\nlemma joinConst_\u03c9continuous (p : D) :", "pos": {"x": 0.5010377168655396, "y": 0.9020435810089111}, "pos3": {"x": 0.43352603912353516, "y": 0.3307531177997589, "z": 0.0}}, {"id": "LoF/Bauer/Eigenforms.lean:joinConst_\u03c9continuous", "name": "joinConst_\u03c9continuous", "kind": "theorem", "path": "LoF/Bauer/Eigenforms.lean", "line": 42, "family": "Other", "snippet": "lemma joinConst_\u03c9continuous (p : D) :\n    OmegaContinuous (D := D) (joinConst (D := D) p) where\n  mono := joinConst_mono (D := D) p\n  map_\u03c9Sup := by\n    intro \u03b1 _", "pos": {"x": 0.5052187442779541, "y": 0.9034152626991272}, "pos3": {"x": 0.43408674001693726, "y": 0.3321938216686249, "z": 0.0023556656669825315}}, {"id": "LoF/Bauer/Eigenforms.lean:lfp_joinConst_eq", "name": "lfp_joinConst_eq", "kind": "theorem", "path": "LoF/Bauer/Eigenforms.lean", "line": 50, "family": "Other", "snippet": "theorem lfp_joinConst_eq (p : D) :\n    lfp (D := D) (joinConst (D := D) p) (joinConst_\u03c9continuous (D := D) p) = p := by\n  have hp : joinConst (D := D) p p = p := by simp [joinConst]\n  apply le_antisymm\n  \u00b7 exact lfp_le_of_isFixed (D := D)", "pos": {"x": 0.5048807263374329, "y": 0.9050169587135315}, "pos3": {"x": 0.4302583634853363, "y": 0.32878491282463074, "z": 0.0024418325629085302}}, {"id": "LoF/Bauer/Eigenforms.lean:lfp_join_process_eq_process", "name": "lfp_join_process_eq_process", "kind": "theorem", "path": "LoF/Bauer/Eigenforms.lean", "line": 72, "family": "Other", "snippet": "theorem lfp_join_process_eq_process :\n    FixedPoint.lfp (D := R.Omega)\n      (joinConst (D := R.Omega) (p := R.process))\n      (joinConst_\u03c9continuous (D := R.Omega) (p := R.process))\n      = R.process := by", "pos": {"x": 0.5011787414550781, "y": 0.8998020887374878}, "pos3": {"x": 0.43265625834465027, "y": 0.33164718747138977, "z": 0.0031897907610982656}}, {"id": "LoF/Bauer/LawvereFixedPoint.lean:PointSurjective", "name": "PointSurjective", "kind": "def", "path": "LoF/Bauer/LawvereFixedPoint.lean", "line": 23, "family": "Other", "snippet": "def PointSurjective {A : Type u} {B : Type v} (e : A \u2192 A \u2192 B) : Prop :=\n  \u2200 g : A \u2192 B, \u2203 a : A, e a = g\n\ntheorem exists_fixedPoint_of_pointSurjective {A : Type u} {B : Type v}\n    (e : A \u2192 A \u2192 B) (he : PointSurjective e) (f : B \u2192 B) :", "pos": {"x": 0.8250989317893982, "y": 0.7646036744117737}, "pos3": {"x": 0.19089314341545105, "y": 0.3231278657913208, "z": 0.7686673402786255}}, {"id": "LoF/Bauer/LawvereFixedPoint.lean:exists_fixedPoint_of_pointSurjective", "name": "exists_fixedPoint_of_pointSurjective", "kind": "theorem", "path": "LoF/Bauer/LawvereFixedPoint.lean", "line": 26, "family": "Other", "snippet": "theorem exists_fixedPoint_of_pointSurjective {A : Type u} {B : Type v}\n    (e : A \u2192 A \u2192 B) (he : PointSurjective e) (f : B \u2192 B) :\n    \u2203 b : B, f b = b := by\n  classical\n  let g : A \u2192 B := fun a => f (e a a)", "pos": {"x": 0.8230335116386414, "y": 0.7632408142089844}, "pos3": {"x": 0.19107796251773834, "y": 0.32231026887893677, "z": 0.7705206274986267}}, {"id": "LoF/Bauer/LawvereFixedPoint.lean:no_pointSurjective_of_noFixedPoint", "name": "no_pointSurjective_of_noFixedPoint", "kind": "theorem", "path": "LoF/Bauer/LawvereFixedPoint.lean", "line": 37, "family": "Other", "snippet": "theorem no_pointSurjective_of_noFixedPoint {A : Type u} {B : Type v}\n    (f : B \u2192 B) (hf : \u2200 b : B, f b \u2260 b) :\n    \u00ac \u2203 e : A \u2192 A \u2192 B, PointSurjective e := by\n  intro h\n  rcases h with \u27e8e, he\u27e9", "pos": {"x": 0.8237505555152893, "y": 0.7623996734619141}, "pos3": {"x": 0.18881124258041382, "y": 0.3203010857105255, "z": 0.7712334990501404}}, {"id": "LoF/Bauer/LawvereFixedPoint.lean:bnot_ne_self", "name": "bnot_ne_self", "kind": "theorem", "path": "LoF/Bauer/LawvereFixedPoint.lean", "line": 45, "family": "Other", "snippet": "theorem bnot_ne_self (b : Bool) : (!b) \u2260 b := by\n  cases b <;> decide\n\ntheorem no_pointSurjective_bool (A : Type u) :\n    \u00ac \u2203 e : A \u2192 A \u2192 Bool, PointSurjective e := by", "pos": {"x": 0.8251779079437256, "y": 0.7615560293197632}, "pos3": {"x": 0.19261571764945984, "y": 0.3236309885978699, "z": 0.7705098390579224}}, {"id": "LoF/Bauer/LawvereFixedPoint.lean:no_pointSurjective_bool", "name": "no_pointSurjective_bool", "kind": "theorem", "path": "LoF/Bauer/LawvereFixedPoint.lean", "line": 48, "family": "Other", "snippet": "theorem no_pointSurjective_bool (A : Type u) :\n    \u00ac \u2203 e : A \u2192 A \u2192 Bool, PointSurjective e := by\n  refine no_pointSurjective_of_noFixedPoint (A := A) (B := Bool) (f := fun b => !b) ?_\n  intro b\n  exact bnot_ne_self b", "pos": {"x": 0.8241407871246338, "y": 0.7632273435592651}, "pos3": {"x": 0.1908583641052246, "y": 0.32436925172805786, "z": 0.7687456607818604}}, {"id": "LoF/Bauer/DomainTheory.lean:OmegaCPPO", "name": "OmegaCPPO", "kind": "structure", "path": "LoF/Bauer/DomainTheory.lean", "line": 34, "family": "Other", "snippet": "class OmegaCPPO (D : Type u) [PartialOrder D] [OrderBot D] where\n  /-- Supremum of an \u03c9-chain. -/\n  sup : (\u03b1 : Nat \u2192 D) \u2192 Monotone \u03b1 \u2192 D\n  /-- Every element of the chain is below the supremum. -/\n  le_sup : \u2200 (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1) (n : Nat), \u03b1 n \u2264 sup \u03b1 h\u03b1", "pos": {"x": 0.5130320191383362, "y": 0.893231213092804}, "pos3": {"x": 0.43534353375434875, "y": 0.3236379623413086, "z": 0.01582394540309906}}, {"id": "LoF/Bauer/DomainTheory.lean:\u03c9Sup", "name": "\u03c9Sup", "kind": "abbrev", "path": "LoF/Bauer/DomainTheory.lean", "line": 46, "family": "Other", "snippet": "abbrev \u03c9Sup (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1) : D :=\n  OmegaCPPO.sup \u03b1 h\u03b1\n\nlemma le_\u03c9Sup (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1) (n : Nat) : \u03b1 n \u2264 \u03c9Sup \u03b1 h\u03b1 :=\n  OmegaCPPO.le_sup \u03b1 h\u03b1 n", "pos": {"x": 0.510901153087616, "y": 0.8986363410949707}, "pos3": {"x": 0.4345845878124237, "y": 0.32528063654899597, "z": 0.00941980630159378}}, {"id": "LoF/Bauer/DomainTheory.lean:le_\u03c9Sup", "name": "le_\u03c9Sup", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 49, "family": "Other", "snippet": "lemma le_\u03c9Sup (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1) (n : Nat) : \u03b1 n \u2264 \u03c9Sup \u03b1 h\u03b1 :=\n  OmegaCPPO.le_sup \u03b1 h\u03b1 n\n\nlemma \u03c9Sup_le (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1) (x : D) (hx : \u2200 n, \u03b1 n \u2264 x) :\n    \u03c9Sup \u03b1 h\u03b1 \u2264 x :=", "pos": {"x": 0.5078460574150085, "y": 0.8893143534660339}, "pos3": {"x": 0.43580320477485657, "y": 0.32335877418518066, "z": 0.01087807584553957}}, {"id": "LoF/Bauer/DomainTheory.lean:\u03c9Sup_le", "name": "\u03c9Sup_le", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 52, "family": "Other", "snippet": "lemma \u03c9Sup_le (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1) (x : D) (hx : \u2200 n, \u03b1 n \u2264 x) :\n    \u03c9Sup \u03b1 h\u03b1 \u2264 x :=\n  OmegaCPPO.sup_le \u03b1 h\u03b1 x hx\n\nend OmegaCPPO", "pos": {"x": 0.5078632831573486, "y": 0.8922094702720642}, "pos3": {"x": 0.4377601444721222, "y": 0.3241533041000366, "z": 0.014356936328113079}}, {"id": "LoF/Bauer/DomainTheory.lean:instOmegaCPPO_ofCompleteLattice", "name": "instOmegaCPPO_ofCompleteLattice", "kind": "instance", "path": "LoF/Bauer/DomainTheory.lean", "line": 60, "family": "Other", "snippet": "instance instOmegaCPPO_ofCompleteLattice (D : Type u) [CompleteLattice D] : OmegaCPPO D where\n  sup \u03b1 _ := iSup \u03b1\n  le_sup \u03b1 _ n := by\n    exact le_iSup (fun k => \u03b1 k) n\n  sup_le \u03b1 _ x hx := by", "pos": {"x": 0.5134060382843018, "y": 0.8881999850273132}, "pos3": {"x": 0.43731874227523804, "y": 0.3278801441192627, "z": 0.010961811989545822}}, {"id": "LoF/Bauer/DomainTheory.lean:OmegaContinuous", "name": "OmegaContinuous", "kind": "structure", "path": "LoF/Bauer/DomainTheory.lean", "line": 76, "family": "Other", "snippet": "structure OmegaContinuous (f : D \u2192 D) : Prop where\n  mono : Monotone f\n  map_\u03c9Sup : \u2200 (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1),\n    f (\u03c9Sup \u03b1 h\u03b1) = \u03c9Sup (fun n => f (\u03b1 n)) (mono.comp h\u03b1)\n", "pos": {"x": 0.503486156463623, "y": 0.892995297908783}, "pos3": {"x": 0.4296010136604309, "y": 0.326986163854599, "z": 0.008173053152859211}}, {"id": "LoF/Bauer/DomainTheory.lean:mono", "name": "mono", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 83, "family": "Other", "snippet": "lemma mono' {f : D \u2192 D} (hf : OmegaContinuous (D := D) f) : Monotone f := hf.mono\n\nend OmegaContinuous\n\n/-- The Kleene iteration chain `\u22a5, f \u22a5, f (f \u22a5), \u2026` as a function `Nat \u2192 D`. -/", "pos": {"x": 0.5011475086212158, "y": 0.8994007110595703}, "pos3": {"x": 0.4376010596752167, "y": 0.33015304803848267, "z": 0.004722160752862692}}, {"id": "LoF/Bauer/DomainTheory.lean:kleeneChain", "name": "kleeneChain", "kind": "def", "path": "LoF/Bauer/DomainTheory.lean", "line": 88, "family": "Other", "snippet": "def kleeneChain (f : D \u2192 D) : Nat \u2192 D\n  | 0 => \u22a5\n  | Nat.succ n => f (kleeneChain f n)\n\nomit [OmegaCPPO D] in", "pos": {"x": 0.5108689069747925, "y": 0.8943445682525635}, "pos3": {"x": 0.43985897302627563, "y": 0.3294367790222168, "z": 0.01393330842256546}}, {"id": "LoF/Bauer/DomainTheory.lean:kleeneChain_le_succ", "name": "kleeneChain_le_succ", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 100, "family": "Other", "snippet": "lemma kleeneChain_le_succ {f : D \u2192 D} (hf : Monotone f) :\n    \u2200 n, kleeneChain (D := D) f n \u2264 kleeneChain (D := D) f (n + 1)\n  | 0 => by\n      simp [kleeneChain]\n  | Nat.succ n => by", "pos": {"x": 0.5080443620681763, "y": 0.8995546698570251}, "pos3": {"x": 0.4355243742465973, "y": 0.33340123295783997, "z": 0.012364783324301243}}, {"id": "LoF/Bauer/DomainTheory.lean:monotone_kleeneChain", "name": "monotone_kleeneChain", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 113, "family": "Other", "snippet": "lemma monotone_kleeneChain {f : D \u2192 D} (hf : Monotone f) :\n    Monotone (kleeneChain (D := D) f) :=\n  monotone_nat_of_le_succ (kleeneChain_le_succ (D := D) hf)\n\nlemma \u03c9Sup_succ_eq_\u03c9Sup_of_bot (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1) (h0 : \u03b1 0 = (\u22a5 : D)) :", "pos": {"x": 0.5105040073394775, "y": 0.9039633870124817}, "pos3": {"x": 0.43380290269851685, "y": 0.3257097005844116, "z": 0.004961133934557438}}, {"id": "LoF/Bauer/DomainTheory.lean:\u03c9Sup_succ_eq_\u03c9Sup_of_bot", "name": "\u03c9Sup_succ_eq_\u03c9Sup_of_bot", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 117, "family": "Other", "snippet": "lemma \u03c9Sup_succ_eq_\u03c9Sup_of_bot (\u03b1 : Nat \u2192 D) (h\u03b1 : Monotone \u03b1) (h0 : \u03b1 0 = (\u22a5 : D)) :\n    \u03c9Sup (fun n => \u03b1 (n + 1)) (h\u03b1.comp (fun _ _ hab => Nat.succ_le_succ hab))\n      = \u03c9Sup \u03b1 h\u03b1 := by\n  have hsucc : Monotone (fun n : Nat => n + 1) := fun _ _ hab => Nat.succ_le_succ hab\n  apply le_antisymm", "pos": {"x": 0.5003085732460022, "y": 0.8901888728141785}, "pos3": {"x": 0.43987971544265747, "y": 0.32548996806144714, "z": 0.004332513082772493}}, {"id": "LoF/Bauer/DomainTheory.lean:lfp", "name": "lfp", "kind": "def", "path": "LoF/Bauer/DomainTheory.lean", "line": 138, "family": "Other", "snippet": "def lfp (f : D \u2192 D) (hf : OmegaContinuous (D := D) f) : D :=\n  \u03c9Sup (kleeneChain (D := D) f) (monotone_kleeneChain (D := D) hf.mono)\n\ntheorem lfp_isFixed (f : D \u2192 D) (hf : OmegaContinuous (D := D) f) :\n    f (lfp (D := D) f hf) = lfp (D := D) f hf := by", "pos": {"x": 0.5108932852745056, "y": 0.8998403549194336}, "pos3": {"x": 0.4413928687572479, "y": 0.3279813826084137, "z": 0.011812224052846432}}, {"id": "LoF/Bauer/DomainTheory.lean:lfp_isFixed", "name": "lfp_isFixed", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 141, "family": "Other", "snippet": "theorem lfp_isFixed (f : D \u2192 D) (hf : OmegaContinuous (D := D) f) :\n    f (lfp (D := D) f hf) = lfp (D := D) f hf := by\n  -- Use \u03c9-continuity to pull `f` through the supremum, then show tail supremum = whole supremum.\n  have hcont := hf.map_\u03c9Sup (kleeneChain (D := D) f) (monotone_kleeneChain (D := D", "pos": {"x": 0.5075533986091614, "y": 0.8933031558990479}, "pos3": {"x": 0.4350185990333557, "y": 0.3352353870868683, "z": 0.010976266115903854}}, {"id": "LoF/Bauer/DomainTheory.lean:lfp_le_of_isFixed", "name": "lfp_le_of_isFixed", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 161, "family": "Other", "snippet": "theorem lfp_le_of_isFixed (f : D \u2192 D) (hf : OmegaContinuous (D := D) f)\n    {q : D} (hq : f q = q) : lfp (D := D) f hf \u2264 q := by\n  -- Show every Kleene iterate is \u2264 q, then use `\u03c9Sup_le`.\n  have hle : \u2200 n, kleeneChain (D := D) f n \u2264 q := by\n    intro n", "pos": {"x": 0.5049070715904236, "y": 0.9013710618019104}, "pos3": {"x": 0.4291519224643707, "y": 0.32769328355789185, "z": 0.006302752066403627}}, {"id": "LoF/Bauer/DomainTheory.lean:ContinuityPrinciple", "name": "ContinuityPrinciple", "kind": "structure", "path": "LoF/Bauer/DomainTheory.lean", "line": 192, "family": "Other", "snippet": "structure ContinuityPrinciple (D : Type u) [PartialOrder D] [OrderBot D] [OmegaCPPO D] : Prop where\n  omegaContinuous : \u2200 f : D \u2192 D, OmegaContinuous (D := D) f\n\n/-- Fixed point induced by the continuity principle (synthetic recursion theorem shape). -/\ndef fix (P : ContinuityPrinciple D) (f : D \u2192 D)", "pos": {"x": 0.5070316791534424, "y": 0.8930744528770447}, "pos3": {"x": 0.42988571524620056, "y": 0.3222019374370575, "z": 0.006588581949472427}}, {"id": "LoF/Bauer/DomainTheory.lean:fix", "name": "fix", "kind": "def", "path": "LoF/Bauer/DomainTheory.lean", "line": 196, "family": "Other", "snippet": "def fix (P : ContinuityPrinciple D) (f : D \u2192 D) : D :=\n  lfp (D := D) f (P.omegaContinuous f)\n\ntheorem fix_isFixed (P : ContinuityPrinciple D) (f : D \u2192 D) :\n    f (fix (D := D) P f) = fix (D := D) P f := by", "pos": {"x": 0.5041557550430298, "y": 0.8962180614471436}, "pos3": {"x": 0.43093550205230713, "y": 0.3325728178024292, "z": 0.01280874852091074}}, {"id": "LoF/Bauer/DomainTheory.lean:fix_isFixed", "name": "fix_isFixed", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 199, "family": "Other", "snippet": "theorem fix_isFixed (P : ContinuityPrinciple D) (f : D \u2192 D) :\n    f (fix (D := D) P f) = fix (D := D) P f := by\n  simpa [fix] using (lfp_isFixed (D := D) f (P.omegaContinuous f))\n\ntheorem fix_le_of_isFixed (P : ContinuityPrinciple D) (f : D \u2192 D) {q : D} (hq : f q = q) :", "pos": {"x": 0.5147766470909119, "y": 0.8896857500076294}, "pos3": {"x": 0.4355076849460602, "y": 0.32548633217811584, "z": 0.01604539528489113}}, {"id": "LoF/Bauer/DomainTheory.lean:fix_le_of_isFixed", "name": "fix_le_of_isFixed", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 203, "family": "Other", "snippet": "theorem fix_le_of_isFixed (P : ContinuityPrinciple D) (f : D \u2192 D) {q : D} (hq : f q = q) :\n    fix (D := D) P f \u2264 q := by\n  simpa [fix] using (lfp_le_of_isFixed (D := D) f (P.omegaContinuous f) hq)\n\nend DomainPrinciples", "pos": {"x": 0.5128841996192932, "y": 0.895528256893158}, "pos3": {"x": 0.44110411405563354, "y": 0.32550355792045593, "z": 0.009457624517381191}}, {"id": "LoF/Bauer/DomainTheory.lean:core", "name": "core", "kind": "def", "path": "LoF/Bauer/DomainTheory.lean", "line": 221, "family": "Other", "snippet": "def core : Set Bool := SyntheticComputability.Toy.core\n\n  /-- Endomap `U \u21a6 U \u222a core` (the demo nucleus action on predicates). -/\n  def adjoinCore (U : Set Bool) : Set Bool := U \u2294 core\n", "pos": {"x": 0.5087555050849915, "y": 0.8869049549102783}, "pos3": {"x": 0.4388432502746582, "y": 0.317434161901474, "z": 0.0102352574467659}}, {"id": "LoF/Bauer/DomainTheory.lean:adjoinCore", "name": "adjoinCore", "kind": "def", "path": "LoF/Bauer/DomainTheory.lean", "line": 224, "family": "Other", "snippet": "  def adjoinCore (U : Set Bool) : Set Bool := U \u2294 core\n\nlemma adjoinCore_mono : Monotone adjoinCore := by\n  intro U V hUV\n  exact sup_le_sup_right hUV core", "pos": {"x": 0.5069503784179688, "y": 0.8893758654594421}, "pos3": {"x": 0.43014344573020935, "y": 0.323178231716156, "z": 0.015184368006885052}}, {"id": "LoF/Bauer/DomainTheory.lean:adjoinCore_mono", "name": "adjoinCore_mono", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 226, "family": "Other", "snippet": "lemma adjoinCore_mono : Monotone adjoinCore := by\n  intro U V hUV\n  exact sup_le_sup_right hUV core\n\nlemma adjoinCore_\u03c9continuous : OmegaContinuous (D := Set Bool) adjoinCore where", "pos": {"x": 0.5129958391189575, "y": 0.8891759514808655}, "pos3": {"x": 0.44574302434921265, "y": 0.3252362012863159, "z": 0.014862339943647385}}, {"id": "LoF/Bauer/DomainTheory.lean:adjoinCore_\u03c9continuous", "name": "adjoinCore_\u03c9continuous", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 230, "family": "Other", "snippet": "lemma adjoinCore_\u03c9continuous : OmegaContinuous (D := Set Bool) adjoinCore where\n  mono := adjoinCore_mono\n  map_\u03c9Sup := by\n    intro \u03b1 _\n    -- In complete lattices, `iSup_sup` provides `(\u2a06 n, \u03b1 n) \u2294 core = \u2a06 n, \u03b1 n \u2294 core`.", "pos": {"x": 0.5071490406990051, "y": 0.888561487197876}, "pos3": {"x": 0.43463510274887085, "y": 0.3195294141769409, "z": 0.010151606053113937}}, {"id": "LoF/Bauer/DomainTheory.lean:core_isFixed", "name": "core_isFixed", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 238, "family": "Other", "snippet": "lemma core_isFixed : adjoinCore core = core := by\n  simp [adjoinCore]\n\ntheorem lfp_adjoinCore_eq_core :\n    lfp (D := Set Bool) adjoinCore adjoinCore_\u03c9continuous = core := by", "pos": {"x": 0.5164453983306885, "y": 0.8967930674552917}, "pos3": {"x": 0.44182702898979187, "y": 0.3205695152282715, "z": 0.013051900081336498}}, {"id": "LoF/Bauer/DomainTheory.lean:lfp_adjoinCore_eq_core", "name": "lfp_adjoinCore_eq_core", "kind": "theorem", "path": "LoF/Bauer/DomainTheory.lean", "line": 241, "family": "Other", "snippet": "theorem lfp_adjoinCore_eq_core :\n    lfp (D := Set Bool) adjoinCore adjoinCore_\u03c9continuous = core := by\n  apply le_antisymm\n  \u00b7 -- minimality: lfp \u2264 core because core is a fixed point\n    exact lfp_le_of_isFixed (D := Set Bool) adjoinCore adjoinCore_\u03c9continuous core_isFixed", "pos": {"x": 0.5153236985206604, "y": 0.8992949724197388}, "pos3": {"x": 0.4394933879375458, "y": 0.31978169083595276, "z": 0.01792413927614689}}, {"id": "LoF/Bauer/ScottReflexiveDomain.lean:scottFix_isFixed", "name": "scottFix_isFixed", "kind": "theorem", "path": "LoF/Bauer/ScottReflexiveDomain.lean", "line": 36, "family": "Other", "snippet": "theorem scottFix_isFixed (f : \u03b1 \u2192\ud835\udc84 \u03b1) : f (scottFix (\u03b1 := \u03b1) f) = scottFix (\u03b1 := \u03b1) f := by\n  -- `\u03c9Sup_iterate_mem_fixedPoint` gives membership in `Function.fixedPoints`.\n  have hmem :\n      scottFix (\u03b1 := \u03b1) f \u2208 Function.fixedPoints f := by\n    simpa [scottFix] using", "pos": {"x": 0.5941045880317688, "y": 0.6598838567733765}, "pos3": {"x": 0.28895649313926697, "y": 0.5413594841957092, "z": 0.9455510973930359}}, {"id": "LoF/Bauer/ScottReflexiveDomain.lean:ReflexiveDomain", "name": "ReflexiveDomain", "kind": "structure", "path": "LoF/Bauer/ScottReflexiveDomain.lean", "line": 59, "family": "Other", "snippet": "structure ReflexiveDomain (\u03b1 : Type u) [OmegaCompletePartialOrder \u03b1] [OrderBot \u03b1] where\n  equivEndo : \u03b1 \u2243 (\u03b1 \u2192\ud835\udc84 \u03b1)\n\nnamespace ReflexiveDomain\n", "pos": {"x": 0.5916308760643005, "y": 0.6584514379501343}, "pos3": {"x": 0.28831127285957336, "y": 0.5371565222740173, "z": 0.9430818557739258}}, {"id": "LoF/Bauer/ScottReflexiveDomain.lean:app", "name": "app", "kind": "def", "path": "LoF/Bauer/ScottReflexiveDomain.lean", "line": 65, "family": "Other", "snippet": "def app (D : ReflexiveDomain (\u03b1 := \u03b1)) (d x : \u03b1) : \u03b1 :=\n  (D.equivEndo d) x\n\n/-- A canonical \u201cY operator\u201d on continuous endomaps, defined via Scott/Kleene iteration. -/\nnoncomputable def Y (_D : ReflexiveDomain (\u03b1 := \u03b1)) (f : \u03b1 \u2192\ud835\udc84 \u03b1) : \u03b1 :=", "pos": {"x": 0.5948455333709717, "y": 0.6614319086074829}, "pos3": {"x": 0.2862144708633423, "y": 0.5458203554153442, "z": 0.9417635202407837}}, {"id": "LoF/Bauer/ScottReflexiveDomain.lean:Y_isFixed", "name": "Y_isFixed", "kind": "theorem", "path": "LoF/Bauer/ScottReflexiveDomain.lean", "line": 72, "family": "Other", "snippet": "theorem Y_isFixed (D : ReflexiveDomain (\u03b1 := \u03b1)) (f : \u03b1 \u2192\ud835\udc84 \u03b1) :\n    f (Y (\u03b1 := \u03b1) D f) = Y (\u03b1 := \u03b1) D f :=\n  scottFix_isFixed (\u03b1 := \u03b1) f\n\nend ReflexiveDomain", "pos": {"x": 0.5966516137123108, "y": 0.6610179543495178}, "pos3": {"x": 0.2861854135990143, "y": 0.5443397164344788, "z": 0.941572368144989}}, {"id": "LoF/Bauer/LawvereCategorical.lean:WeaklyPointSurjective", "name": "WeaklyPointSurjective", "kind": "def", "path": "LoF/Bauer/LawvereCategorical.lean", "line": 34, "family": "Other", "snippet": "def WeaklyPointSurjective (\u03c6 : A \u27f6 A \u27f9 B) : Prop :=\n  \u2200 g : \ud835\udfd9_ C \u27f6 A \u27f9 B, \u2203 a : \ud835\udfd9_ C \u27f6 A, a \u226b \u03c6 = g\n\nprivate def diag (A : C) : A \u27f6 A \u2297 A :=\n  lift (\ud835\udfd9 A) (\ud835\udfd9 A)", "pos": {"x": 0.8178123831748962, "y": 0.7542527318000793}, "pos3": {"x": 0.18659111857414246, "y": 0.31697535514831543, "z": 0.7700939178466797}}, {"id": "LoF/Bauer/LawvereCategorical.lean:exists_fixedPoint_of_weaklyPointSurjective", "name": "exists_fixedPoint_of_weaklyPointSurjective", "kind": "theorem", "path": "LoF/Bauer/LawvereCategorical.lean", "line": 105, "family": "Other", "snippet": "theorem exists_fixedPoint_of_weaklyPointSurjective\n    (\u03c6 : A \u27f6 A \u27f9 B) (h\u03c6 : WeaklyPointSurjective (A := A) (B := B) \u03c6) (f : B \u27f6 B) :\n    \u2203 b : \ud835\udfd9_ C \u27f6 B, b \u226b f = b := by\n  classical\n  let d : A \u27f6 B := selfApply (A := A) (B := B) \u03c6", "pos": {"x": 0.8189653158187866, "y": 0.7564604878425598}, "pos3": {"x": 0.18973249197006226, "y": 0.31925392150878906, "z": 0.7701382637023926}}, {"id": "LoF/Bauer/SyntheticComputability.lean:Axioms", "name": "Axioms", "kind": "structure", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 36, "family": "Other", "snippet": "structure Axioms (\u03a9 : Type u) [Order.Frame \u03a9] (J : Nucleus \u03a9) where\n  /-- Markov principle, restricted to `J`-closed (\u201csemidecidable\u201d) truth values. -/\n  markov : \u2200 p : J.toSublocale, ((p : \u03a9)\u1d9c\u1d9c \u2264 (p : \u03a9))\n  /-- Countability of the closed truth values (kept as an assumption, not a concrete enumerato", "pos": {"x": 0.8980865478515625, "y": 0.09681253135204315}, "pos3": {"x": 0.9930499196052551, "y": 0.4432836174964905, "z": 0.34931179881095886}}, {"id": "LoF/Bauer/SyntheticComputability.lean:World", "name": "World", "kind": "structure", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 45, "family": "Other", "snippet": "structure World (\u03a9 : Type u) [Order.Frame \u03a9] where\n  /-- The computability modality as a Lawvere\u2013Tierney nucleus on `\u03a9`. -/\n  J : Nucleus \u03a9\n  /-- Additional principles (Markov, enumerability, \u2026) attached to this world. -/\n  axioms : Axioms (\u03a9 := \u03a9) J", "pos": {"x": 0.9038208723068237, "y": 0.09725312143564224}, "pos3": {"x": 0.999286949634552, "y": 0.43904873728752136, "z": 0.3476788103580475}}, {"id": "LoF/Bauer/SyntheticComputability.lean:\u03a9J", "name": "\u03a9J", "kind": "abbrev", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 57, "family": "Other", "snippet": "abbrev \u03a9J : Type u := W.J.toSublocale\n\nlemma markov (p : W.\u03a9J) : ((p : \u03a9)\u1d9c\u1d9c \u2264 (p : \u03a9)) :=\n  W.axioms.markov p\n", "pos": {"x": 0.9038376212120056, "y": 0.0990331843495369}, "pos3": {"x": 0.9940683245658875, "y": 0.4379351735115051, "z": 0.3494311571121216}}, {"id": "LoF/Bauer/SyntheticComputability.lean:markov", "name": "markov", "kind": "theorem", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 59, "family": "Other", "snippet": "lemma markov (p : W.\u03a9J) : ((p : \u03a9)\u1d9c\u1d9c \u2264 (p : \u03a9)) :=\n  W.axioms.markov p\n\nlemma countable : Countable W.\u03a9J :=\n  W.axioms.countable", "pos": {"x": 0.9023907780647278, "y": 0.09797224402427673}, "pos3": {"x": 0.9977976083755493, "y": 0.4394066631793976, "z": 0.345195472240448}}, {"id": "LoF/Bauer/SyntheticComputability.lean:countable", "name": "countable", "kind": "theorem", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 62, "family": "Other", "snippet": "lemma countable : Countable W.\u03a9J :=\n  W.axioms.countable\n\nend World\n", "pos": {"x": 0.9055132865905762, "y": 0.09796358644962311}, "pos3": {"x": 0.9945266842842102, "y": 0.4399279057979584, "z": 0.34343579411506653}}, {"id": "LoF/Bauer/SyntheticComputability.lean:adjoinNucleus", "name": "adjoinNucleus", "kind": "def", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 74, "family": "LoF", "snippet": "def adjoinNucleus (K : Set \u03b9) : Nucleus (Set \u03b9) where\n  toFun U := U \u222a K\n  map_inf' U V := by\n    simpa using (Set.inter_union_distrib_right U V K)\n  idempotent' U := by", "pos": {"x": 0.9026640057563782, "y": 0.10033411532640457}, "pos3": {"x": 0.9921713471412659, "y": 0.44186708331108093, "z": 0.34578192234039307}}, {"id": "LoF/Bauer/SyntheticComputability.lean:adjoinNucleus_fixed_iff", "name": "adjoinNucleus_fixed_iff", "kind": "theorem", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 90, "family": "LoF", "snippet": "lemma adjoinNucleus_fixed_iff (K U : Set \u03b9) :\n    adjoinNucleus (\u03b9 := \u03b9) K U = U \u2194 K \u2286 U := by\n  constructor\n  \u00b7 intro h x hx\n    have : x \u2208 adjoinNucleus (\u03b9 := \u03b9) K U := by", "pos": {"x": 0.9008790850639343, "y": 0.09831734001636505}, "pos3": {"x": 0.9950319528579712, "y": 0.44627004861831665, "z": 0.35062655806541443}}, {"id": "LoF/Bauer/SyntheticComputability.lean:mem_toSublocale_iff", "name": "mem_toSublocale_iff", "kind": "theorem", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 107, "family": "Other", "snippet": "lemma mem_toSublocale_iff (K U : Set \u03b9) :\n    U \u2208 (adjoinNucleus (\u03b9 := \u03b9) K).toSublocale \u2194 K \u2286 U := by\n  constructor\n  \u00b7 intro hU\n    rcases hU with \u27e8V, rfl\u27e9", "pos": {"x": 0.8977652192115784, "y": 0.0953931137919426}, "pos3": {"x": 0.9979504942893982, "y": 0.4462568759918213, "z": 0.35228443145751953}}, {"id": "LoF/Bauer/SyntheticComputability.lean:core", "name": "core", "kind": "def", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 128, "family": "Other", "snippet": "def core : Set Bool := {false}\n\n/-- Demo computability nucleus: `U \u21a6 U \u222a {false}` on `Set Bool`. -/\ndef J : Nucleus (Set Bool) :=\n  Predicate.adjoinNucleus (\u03b9 := Bool) core", "pos": {"x": 0.9042673707008362, "y": 0.09256081283092499}, "pos3": {"x": 0.9928370118141174, "y": 0.44520291686058044, "z": 0.346239298582077}}, {"id": "LoF/Bauer/SyntheticComputability.lean:J", "name": "J", "kind": "def", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 131, "family": "Other", "snippet": "def J : Nucleus (Set Bool) :=\n  Predicate.adjoinNucleus (\u03b9 := Bool) core\n\n/-- Closed truth values for the demo nucleus. Use `abbrev` so coercions remain definitional. -/\nabbrev \u03a9J : Type :=", "pos": {"x": 0.9016774892807007, "y": 0.09247734397649765}, "pos3": {"x": 0.995753288269043, "y": 0.4413573741912842, "z": 0.3506591320037842}}, {"id": "LoF/Bauer/SyntheticComputability.lean:\u03a9J", "name": "\u03a9J", "kind": "abbrev", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 135, "family": "Other", "snippet": "abbrev \u03a9J : Type :=\n  (J.toSublocale)\n\nlemma mem\u03a9J_iff (U : Set Bool) : U \u2208 J.toSublocale \u2194 core \u2286 U := by\n  simpa [J] using (Predicate.mem_toSublocale_iff (\u03b9 := Bool) (K := core) (U := U))", "pos": {"x": 0.9053394794464111, "y": 0.09357426315546036}, "pos3": {"x": 0.9975824952125549, "y": 0.44110459089279175, "z": 0.34595024585723877}}, {"id": "LoF/Bauer/SyntheticComputability.lean:mem\u03a9J_iff", "name": "mem\u03a9J_iff", "kind": "theorem", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 138, "family": "Other", "snippet": "lemma mem\u03a9J_iff (U : Set Bool) : U \u2208 J.toSublocale \u2194 core \u2286 U := by\n  simpa [J] using (Predicate.mem_toSublocale_iff (\u03b9 := Bool) (K := core) (U := U))\n\ndef \u03a90 : \u03a9J :=\n  \u27e8core, (mem\u03a9J_iff (U := core)).2 subset_rfl\u27e9", "pos": {"x": 0.9075141549110413, "y": 0.1010184958577156}, "pos3": {"x": 0.9986567497253418, "y": 0.4453248977661133, "z": 0.3489948809146881}}, {"id": "LoF/Bauer/SyntheticComputability.lean:\u03a90", "name": "\u03a90", "kind": "def", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 141, "family": "Other", "snippet": "def \u03a90 : \u03a9J :=\n  \u27e8core, (mem\u03a9J_iff (U := core)).2 subset_rfl\u27e9\n\ndef \u03a9top : \u03a9J :=\n  \u27e8(\u22a4 : Set Bool), (mem\u03a9J_iff (U := (\u22a4 : Set Bool))).2 (by simpa using (Set.subset_univ core))\u27e9", "pos": {"x": 0.9013985991477966, "y": 0.092937171459198}, "pos3": {"x": 0.9942798614501953, "y": 0.43996819853782654, "z": 0.3518316149711609}}, {"id": "LoF/Bauer/SyntheticComputability.lean:\u03a9top", "name": "\u03a9top", "kind": "def", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 144, "family": "Other", "snippet": "def \u03a9top : \u03a9J :=\n  \u27e8(\u22a4 : Set Bool), (mem\u03a9J_iff (U := (\u22a4 : Set Bool))).2 (by simpa using (Set.subset_univ core))\u27e9\n\n/-- Classify a closed truth value by whether `true` is in the underlying set. -/\nnoncomputable def toBool (p : \u03a9J) : Bool := by", "pos": {"x": 0.8992430567741394, "y": 0.09421870857477188}, "pos3": {"x": 0.9921871423721313, "y": 0.4459371864795685, "z": 0.3473876714706421}}, {"id": "LoF/Bauer/SyntheticComputability.lean:ofBool", "name": "ofBool", "kind": "def", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 152, "family": "Other", "snippet": "def ofBool (b : Bool) : \u03a9J :=\n  if b then \u03a9top else \u03a90\n\nnoncomputable def equivBool : \u03a9J \u2243 Bool where\n  toFun := toBool", "pos": {"x": 0.9075555205345154, "y": 0.09875130653381348}, "pos3": {"x": 0.9952094554901123, "y": 0.44490793347358704, "z": 0.3460692763328552}}, {"id": "LoF/Bauer/SyntheticComputability.lean:countable_\u03a9J", "name": "countable_\u03a9J", "kind": "theorem", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 179, "family": "Other", "snippet": "lemma countable_\u03a9J : Countable \u03a9J := by\n  classical\n  -- `\u03a9J` is equivalent to `Bool`.\n  exact Countable.of_equiv Bool (equivBool.symm)\n", "pos": {"x": 0.9075537323951721, "y": 0.10354536771774292}, "pos3": {"x": 0.990111768245697, "y": 0.44092926383018494, "z": 0.3517509996891022}}, {"id": "LoF/Bauer/SyntheticComputability.lean:eq_\u03a90_or_eq_\u03a9top", "name": "eq_\u03a90_or_eq_\u03a9top", "kind": "theorem", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 184, "family": "Other", "snippet": "lemma eq_\u03a90_or_eq_\u03a9top (p : \u03a9J) : p = \u03a90 \u2228 p = \u03a9top := by\n  classical\n  -- Every closed truth value is `\u03a90` or `\u03a9top`, since `\u03a9J \u2243 Bool`.\n  have hp : ofBool (equivBool p) = p :=\n    equivBool.left_inv p", "pos": {"x": 0.8997675776481628, "y": 0.10064813494682312}, "pos3": {"x": 1.0, "y": 0.44210055470466614, "z": 0.34641605615615845}}, {"id": "LoF/Bauer/SyntheticComputability.lean:axioms", "name": "axioms", "kind": "def", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 199, "family": "Other", "snippet": "def axioms : Axioms (\u03a9 := Set Bool) J where\n  markov := by\n    intro p\n    -- Ambient double negation is trivial for `Set Bool`.\n    simp", "pos": {"x": 0.9075512886047363, "y": 0.09053684771060944}, "pos3": {"x": 0.9962349534034729, "y": 0.4444166123867035, "z": 0.34150680899620056}}, {"id": "LoF/Bauer/SyntheticComputability.lean:world", "name": "world", "kind": "def", "path": "LoF/Bauer/SyntheticComputability.lean", "line": 207, "family": "Other", "snippet": "def world : World (\u03a9 := Set Bool) where\n  J := J\n  axioms := axioms\n\nend Toy", "pos": {"x": 0.8969517350196838, "y": 0.10098569840192795}, "pos3": {"x": 0.9975783228874207, "y": 0.436481773853302, "z": 0.34669229388237}}, {"id": "LoF/Bauer/DoubleNegation.lean:doubleNegNucleus", "name": "doubleNegNucleus", "kind": "def", "path": "LoF/Bauer/DoubleNegation.lean", "line": 26, "family": "LoF", "snippet": "def doubleNegNucleus : Nucleus \u03b1 where\n  toFun a := a\u1d9c\u1d9c\n  map_inf' a b := by\n    simpa using (compl_compl_inf_distrib (a := a) (b := b))\n  idempotent' a := by", "pos": {"x": 0.45900413393974304, "y": 0.29121068120002747}, "pos3": {"x": 0.5545681715011597, "y": 0.42741259932518005, "z": 0.4195649027824402}}, {"id": "LoF/Bauer/DoubleNegation.lean:ClassicalCore", "name": "ClassicalCore", "kind": "abbrev", "path": "LoF/Bauer/DoubleNegation.lean", "line": 42, "family": "Other", "snippet": "abbrev ClassicalCore : Type u :=\n  Regular \u03b1\n\ninstance : BooleanAlgebra (ClassicalCore \u03b1) := by\n  dsimp [ClassicalCore]", "pos": {"x": 0.4592280387878418, "y": 0.29165205359458923}, "pos3": {"x": 0.5569054484367371, "y": 0.4279910624027252, "z": 0.4216136932373047}}, {"id": "LoF/Bauer/DoubleNegation.lean:toClassicalCore", "name": "toClassicalCore", "kind": "abbrev", "path": "LoF/Bauer/DoubleNegation.lean", "line": 50, "family": "Other", "snippet": "abbrev toClassicalCore : \u03b1 \u2192o ClassicalCore \u03b1 :=\n  Regular.toRegular\n\n@[simp] lemma coe_toClassicalCore (a : \u03b1) :\n    ((toClassicalCore \u03b1 a : ClassicalCore \u03b1) : \u03b1) = doubleNegNucleus \u03b1 a := rfl", "pos": {"x": 0.45932537317276, "y": 0.2908620238304138}, "pos3": {"x": 0.5547029376029968, "y": 0.42658889293670654, "z": 0.41931089758872986}}, {"id": "LoF/LoFPrimary/Syntax.lean:marked", "name": "marked", "kind": "def", "path": "LoF/LoFPrimary/Syntax.lean", "line": 36, "family": "Other", "snippet": "def marked : Expr n :=\n  mark void\n\nend Expr\n", "pos": {"x": 0.8133565187454224, "y": 0.7433604598045349}, "pos3": {"x": 0.17937132716178894, "y": 0.3098289668560028, "z": 0.7659028172492981}}, {"id": "LoF/LoFPrimary/Normalization.lean:eval", "name": "eval", "kind": "def", "path": "LoF/LoFPrimary/Normalization.lean", "line": 39, "family": "Other", "snippet": "def eval : Expr n \u2192 (Fin n \u2192 Bool) \u2192 Bool\n  | .void, _ => false\n  | .var i, \u03c1 => \u03c1 i\n  | .mark A, \u03c1 => !(eval A \u03c1)\n  | .juxt A B, \u03c1 => eval A \u03c1 || eval B \u03c1", "pos": {"x": 0.8154325485229492, "y": 0.7509294152259827}, "pos3": {"x": 0.18477407097816467, "y": 0.31458577513694763, "z": 0.7690491080284119}}, {"id": "LoF/LoFPrimary/Normalization.lean:trueSet", "name": "trueSet", "kind": "def", "path": "LoF/LoFPrimary/Normalization.lean", "line": 48, "family": "Other", "snippet": "def trueSet (A : Expr n) : Finset (Fin n \u2192 Bool) :=\n  Finset.filter (fun \u03c1 => eval A \u03c1 = true) Finset.univ\n\n@[simp] theorem mem_trueSet {A : Expr n} {\u03c1 : Fin n \u2192 Bool} :\n    \u03c1 \u2208 trueSet (n := n) A \u2194 eval A \u03c1 = true := by", "pos": {"x": 0.8137561082839966, "y": 0.7515338063240051}, "pos3": {"x": 0.1844317466020584, "y": 0.3154301345348358, "z": 0.7711731791496277}}, {"id": "LoF/LoFPrimary/Normalization.lean:Eqv", "name": "Eqv", "kind": "def", "path": "LoF/LoFPrimary/Normalization.lean", "line": 58, "family": "Other", "snippet": "def Eqv (A B : Expr n) : Prop :=\n  \u2200 \u03c1 : Fin n \u2192 Bool, eval A \u03c1 = eval B \u03c1\n\ntheorem eqv_iff_trueSet_eq {A B : Expr n} :\n    Eqv (n := n) A B \u2194 trueSet (n := n) A = trueSet (n := n) B := by", "pos": {"x": 0.8153047561645508, "y": 0.7504031658172607}, "pos3": {"x": 0.185673788189888, "y": 0.3144254684448242, "z": 0.7715749144554138}}, {"id": "LoF/LoFPrimary/Normalization.lean:eqv_iff_trueSet_eq", "name": "eqv_iff_trueSet_eq", "kind": "theorem", "path": "LoF/LoFPrimary/Normalization.lean", "line": 61, "family": "Other", "snippet": "theorem eqv_iff_trueSet_eq {A B : Expr n} :\n    Eqv (n := n) A B \u2194 trueSet (n := n) A = trueSet (n := n) B := by\n  constructor\n  \u00b7 intro h\n    ext \u03c1", "pos": {"x": 0.8164142370223999, "y": 0.7518548965454102}, "pos3": {"x": 0.1850235015153885, "y": 0.3162457346916199, "z": 0.77238529920578}}, {"id": "LoF/LoFPrimary/Normalization.lean:step_sound", "name": "step_sound", "kind": "theorem", "path": "LoF/LoFPrimary/Normalization.lean", "line": 82, "family": "Other", "snippet": "theorem step_sound {A B : Expr n} : Step A B \u2192 Eqv (n := n) A B := by\n  intro h \u03c1\n  induction h with\n  | calling A =>\n      simp [eval, Bool.or_self]", "pos": {"x": 0.8170338273048401, "y": 0.7514142990112305}, "pos3": {"x": 0.18733222782611847, "y": 0.3130555748939514, "z": 0.7697976231575012}}, {"id": "LoF/LoFPrimary/Normalization.lean:steps_sound", "name": "steps_sound", "kind": "theorem", "path": "LoF/LoFPrimary/Normalization.lean", "line": 100, "family": "Other", "snippet": "theorem steps_sound {A B : Expr n} : Steps A B \u2192 Eqv (n := n) A B := by\n  intro h\n  induction h with\n  | refl A =>\n      intro \u03c1", "pos": {"x": 0.8148273825645447, "y": 0.753710150718689}, "pos3": {"x": 0.18560799956321716, "y": 0.312358021736145, "z": 0.7683915495872498}}, {"id": "LoF/LoFPrimary/Rewrite.lean:transitive", "name": "transitive", "kind": "theorem", "path": "LoF/LoFPrimary/Rewrite.lean", "line": 45, "family": "Other", "snippet": "theorem transitive {A B C : Expr n} : Steps A B \u2192 Steps B C \u2192 Steps A C := by\n  intro hAB hBC\n  induction hAB with\n  | refl _ =>\n      simpa using hBC", "pos": {"x": 0.811837375164032, "y": 0.7429221868515015}, "pos3": {"x": 0.17928682267665863, "y": 0.30968236923217773, "z": 0.7670764923095703}}, {"id": "Topos/DimensionalRatchetTranslate.lean:sasakiHook_le_himp_in_omega", "name": "sasakiHook_le_himp_in_omega", "kind": "theorem", "path": "Topos/DimensionalRatchetTranslate.lean", "line": 44, "family": "Other", "snippet": "theorem sasakiHook_le_himp_in_omega\n    {\u03b2 : Type _} {\u03b1 : Type _}\n    [OrthocomplementedLattice \u03b2] [OrthomodularLattice \u03b2]\n    [Order.Frame \u03b1] [HasCompl \u03b1]\n    (T : QLMap \u03b2 \u03b1) [QLMap.ComplPreserving T] (a b : \u03b2) :", "pos": {"x": 0.47864052653312683, "y": 0.2451697289943695}, "pos3": {"x": 0.5512251853942871, "y": 0.37815147638320923, "z": 0.4071149528026581}}, {"id": "Topos/DimensionalRatchet.lean:proj_idempotent", "name": "proj_idempotent", "kind": "theorem", "path": "Topos/DimensionalRatchet.lean", "line": 52, "family": "Other", "snippet": "theorem proj_idempotent (a b : \u03b1) : a \u25b7 (a \u25b7 b) = a \u25b7 b := by\n  -- `a \u25b7 b \u2264 a`, so `a \u25b7 (a \u25b7 b) = a \u25b7 b` by the \u201cbelow the projector\u201d lemma.\n  have hle : a \u25b7 b \u2264 a := OML.sasakiProj_le_left (a := a) (b := b)\n  exact OML.sasakiProj_id_of_le (a := a) (b := (a \u25b7 b)) hle\n", "pos": {"x": 0.45958948135375977, "y": 0.29028084874153137}, "pos3": {"x": 0.5555894374847412, "y": 0.42534691095352173, "z": 0.4186908006668091}}, {"id": "Topos/DimensionalRatchet.lean:doubleNegNucleus", "name": "doubleNegNucleus", "kind": "abbrev", "path": "Topos/DimensionalRatchet.lean", "line": 69, "family": "LoF", "snippet": "abbrev doubleNegNucleus := HeytingLean.LoF.Bauer.doubleNegNucleus \u03b1\nabbrev ClassicalCore := HeytingLean.LoF.Bauer.ClassicalCore \u03b1\n\n/-- The double-negation classical core carries a Boolean algebra structure. -/\ndef classicalCoreBoolean : BooleanAlgebra (ClassicalCore \u03b1) := by", "pos": {"x": 0.4590981602668762, "y": 0.29044485092163086}, "pos3": {"x": 0.554611086845398, "y": 0.425872266292572, "z": 0.4191974401473999}}, {"id": "Topos/DimensionalRatchet.lean:ClassicalCore", "name": "ClassicalCore", "kind": "abbrev", "path": "Topos/DimensionalRatchet.lean", "line": 70, "family": "Other", "snippet": "abbrev ClassicalCore := HeytingLean.LoF.Bauer.ClassicalCore \u03b1\n\n/-- The double-negation classical core carries a Boolean algebra structure. -/\ndef classicalCoreBoolean : BooleanAlgebra (ClassicalCore \u03b1) := by\n  dsimp [ClassicalCore]", "pos": {"x": 0.456769198179245, "y": 0.2900789678096771}, "pos3": {"x": 0.5557113289833069, "y": 0.42429032921791077, "z": 0.42072075605392456}}, {"id": "Topos/DimensionalRatchet.lean:classicalCoreBoolean", "name": "classicalCoreBoolean", "kind": "def", "path": "Topos/DimensionalRatchet.lean", "line": 73, "family": "Other", "snippet": "def classicalCoreBoolean : BooleanAlgebra (ClassicalCore \u03b1) := by\n  dsimp [ClassicalCore]\n  infer_instance\n\nend Bauer", "pos": {"x": 0.4610903561115265, "y": 0.2886963188648224}, "pos3": {"x": 0.5533090829849243, "y": 0.42323723435401917, "z": 0.42177072167396545}}, {"id": "Topos/DimensionalRatchet.lean:OMLToHeyting", "name": "OMLToHeyting", "kind": "structure", "path": "Topos/DimensionalRatchet.lean", "line": 90, "family": "Quantum", "snippet": "structure OMLToHeyting (\u03b2 : Type _) [OrthocomplementedLattice \u03b2] [OrthomodularLattice \u03b2] where\n  (H : Type _)\n  [instHeyting : HeytingAlgebra H]\n\nattribute [instance] OMLToHeyting.instHeyting", "pos": {"x": 0.46421581506729126, "y": 0.28553521633148193}, "pos3": {"x": 0.5551999807357788, "y": 0.4261869788169861, "z": 0.4193119704723358}}, {"id": "Numbers/SurrealCore.lean:PreGame", "name": "PreGame", "kind": "structure", "path": "Numbers/SurrealCore.lean", "line": 21, "family": "Other", "snippet": "structure PreGame where\n  L : List PreGame := []\n  R : List PreGame := []\n  birth : Nat := 0\nderiving Repr", "pos": {"x": 0.9992139935493469, "y": 0.7495315670967102}, "pos3": {"x": 0.0, "y": 0.5102789402008057, "z": 0.9866057634353638}}, {"id": "Numbers/SurrealCore.lean:maxBirth", "name": "maxBirth", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 29, "family": "Other", "snippet": "def maxBirth (xs : List PreGame) : Nat :=\n  xs.foldl (fun acc g => Nat.max acc g.birth) 0\n\n/-- Smart constructor that updates `birth` from child lists. -/\ndef build (L R : List PreGame) : PreGame :=", "pos": {"x": 1.0, "y": 0.7486266493797302}, "pos3": {"x": 0.0034328289330005646, "y": 0.5105491280555725, "z": 0.9905890226364136}}, {"id": "Numbers/SurrealCore.lean:build", "name": "build", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 33, "family": "Other", "snippet": "def build (L R : List PreGame) : PreGame :=\n  { L := L\n    R := R\n    birth := Nat.succ (Nat.max (maxBirth L) (maxBirth R)) }\n", "pos": {"x": 0.9953980445861816, "y": 0.7529025077819824}, "pos3": {"x": 0.005348179489374161, "y": 0.5098755955696106, "z": 0.9921759366989136}}, {"id": "Numbers/SurrealCore.lean:nullCut", "name": "nullCut", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 43, "family": "Other", "snippet": "def nullCut : PreGame :=\n  { L := [], R := [], birth := 0 }\n\ndef birthday (g : PreGame) : Nat := g.birth\n", "pos": {"x": 0.9911984205245972, "y": 0.7449078559875488}, "pos3": {"x": 0.008448849432170391, "y": 0.507354199886322, "z": 0.9873523712158203}}, {"id": "Numbers/SurrealCore.lean:birthday", "name": "birthday", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 46, "family": "Other", "snippet": "def birthday (g : PreGame) : Nat := g.birth\n\ndef truncate (\u03b8 : Nat) (g : PreGame) : Option PreGame :=\n  if birthday g \u2264 \u03b8 then some g else none\n", "pos": {"x": 0.9903730750083923, "y": 0.7493355870246887}, "pos3": {"x": 0.010006803087890148, "y": 0.5086416006088257, "z": 0.9830524921417236}}, {"id": "Numbers/SurrealCore.lean:truncate", "name": "truncate", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 48, "family": "Other", "snippet": "def truncate (\u03b8 : Nat) (g : PreGame) : Option PreGame :=\n  if birthday g \u2264 \u03b8 then some g else none\n\n/-- Finite-day comparison core (rank-indexed): `leAt k x y` computes `x \u2264 y` up to budget `k`. -/\nnoncomputable def leAt : Nat \u2192 PreGame \u2192 PreGame \u2192 Prop", "pos": {"x": 0.9881154298782349, "y": 0.7514633536338806}, "pos3": {"x": 0.00901989545673132, "y": 0.5108956694602966, "z": 0.9869248867034912}}, {"id": "Numbers/SurrealCore.lean:canonicalize", "name": "canonicalize", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 69, "family": "Other", "snippet": "def canonicalize (g : PreGame) : PreGame := g\n\n/-- Surreal closure hook: canonicalise and assume legality is enforced upstream. -/\ndef close (g : PreGame) : PreGame := canonicalize g\n", "pos": {"x": 0.9918484687805176, "y": 0.7446273565292358}, "pos3": {"x": 0.0074671171605587006, "y": 0.5045970678329468, "z": 0.9885264039039612}}, {"id": "Numbers/SurrealCore.lean:close", "name": "close", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 72, "family": "Other", "snippet": "def close (g : PreGame) : PreGame := canonicalize g\n\ntheorem canonicalize_idem (g : PreGame) :\n    canonicalize (canonicalize g) = canonicalize g := rfl\n", "pos": {"x": 0.9965016841888428, "y": 0.7560571432113647}, "pos3": {"x": 0.0013951084110885859, "y": 0.5091199278831482, "z": 0.9916731715202332}}, {"id": "Numbers/SurrealCore.lean:canonicalize_idem", "name": "canonicalize_idem", "kind": "theorem", "path": "Numbers/SurrealCore.lean", "line": 74, "family": "Other", "snippet": "theorem canonicalize_idem (g : PreGame) :\n    canonicalize (canonicalize g) = canonicalize g := rfl\n\n/-! ## Arithmetic skeleton (to be refined) -/\n", "pos": {"x": 0.9986984729766846, "y": 0.7516449689865112}, "pos3": {"x": 0.004677721299231052, "y": 0.5146336555480957, "z": 0.9887070059776306}}, {"id": "Numbers/SurrealCore.lean:add", "name": "add", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 92, "family": "Other", "snippet": "def add (x y : PreGame) : PreGame :=\n  addAt (Nat.succ (x.birth + y.birth)) x y\n\n/-- Conway negation on pre-games: swap left/right options recursively. -/\nprivate def negAt : Nat \u2192 PreGame \u2192 PreGame", "pos": {"x": 0.9980985522270203, "y": 0.754533052444458}, "pos3": {"x": 0.007175289560109377, "y": 0.512901246547699, "z": 0.9919583797454834}}, {"id": "Numbers/SurrealCore.lean:neg", "name": "neg", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 100, "family": "Other", "snippet": "def neg (x : PreGame) : PreGame :=\n  negAt (Nat.succ x.birth) x\n\nprivate def sub (x y : PreGame) : PreGame := add x (neg y)\n", "pos": {"x": 0.9959967136383057, "y": 0.753478467464447}, "pos3": {"x": 0.0020822822116315365, "y": 0.5110065937042236, "z": 0.9919885993003845}}, {"id": "Numbers/SurrealCore.lean:mul", "name": "mul", "kind": "def", "path": "Numbers/SurrealCore.lean", "line": 134, "family": "Other", "snippet": "def mul (x y : PreGame) : PreGame :=\n  mulAt (Nat.succ (x.birth + y.birth)) x y\n\nend SurrealCore\nend Numbers", "pos": {"x": 0.9956203699111938, "y": 0.7533613443374634}, "pos3": {"x": 0.0047258357517421246, "y": 0.511823296546936, "z": 0.9907775521278381}}, {"id": "Numbers/Surreal/BridgeToPGamePreservation.lean:toIGame_negConway", "name": "toIGame_negConway", "kind": "theorem", "path": "Numbers/Surreal/BridgeToPGamePreservation.lean", "line": 213, "family": "Other", "snippet": "theorem toIGame_negConway (x : PreGame) :\n    toIGame (negConway x) = - toIGame x := by\n  classical\n  refine (measure (fun g : PreGame => sizeOf g)).wf.induction x\n    (C := fun g => toIGame (negConway g) = -toIGame g) ?_", "pos": {"x": 0.9945215582847595, "y": 0.7675490379333496}, "pos3": {"x": 0.010323252528905869, "y": 0.503732442855835, "z": 1.0}}, {"id": "Numbers/Surreal/BridgeToPGamePreservation.lean:toIGame_addConway", "name": "toIGame_addConway", "kind": "theorem", "path": "Numbers/Surreal/BridgeToPGamePreservation.lean", "line": 331, "family": "Other", "snippet": "theorem toIGame_addConway (x y : PreGame) :\n    toIGame (addConway x y) = toIGame x + toIGame y := by\n  classical\n  refine (measure (fun p : PreGame \u00d7 PreGame => sizeOf p.1 + sizeOf p.2)).wf.induction (x, y)\n    (C := fun p => toIGame (addConway p.1 p.2) = toIGame p.1 + toIGame p.2) ?_", "pos": {"x": 0.9937147498130798, "y": 0.766201913356781}, "pos3": {"x": 0.011126265861093998, "y": 0.5036723613739014, "z": 0.9999833106994629}}, {"id": "Numbers/Surreal/BridgeToFGame.lean:toFGame", "name": "toFGame", "kind": "def", "path": "Numbers/Surreal/BridgeToFGame.lean", "line": 95, "family": "Other", "snippet": "def toFGame : PreGame \u2192 FGame\n  | { L := L, R := R, birth := _ } =>\n      let L' := L.map toFGame\n      let R' := R.map toFGame\n      FGame.ofLists L' R'", "pos": {"x": 0.9949551820755005, "y": 0.7691110372543335}, "pos3": {"x": 0.01216578483581543, "y": 0.5039494633674622, "z": 0.9991320371627808}}, {"id": "Numbers/Surreal/LoFDerivation.lean:Distinction", "name": "Distinction", "kind": "structure", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 33, "family": "Other", "snippet": "structure Distinction (\u03b1 : Type _) where\n  inside : \u03b1\n  outside : \u03b1\n\nnamespace Distinction", "pos": {"x": 0.9882574081420898, "y": 0.740696907043457}, "pos3": {"x": 0.013841241598129272, "y": 0.5031980872154236, "z": 0.9817265272140503}}, {"id": "Numbers/Surreal/LoFDerivation.lean:mark", "name": "mark", "kind": "def", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 40, "family": "Other", "snippet": "def mark {\u03b1 : Type _} (d : Distinction \u03b1) : Distinction \u03b1 :=\n  \u27e8d.outside, d.inside\u27e9\n\n@[simp] theorem mark_inside {\u03b1 : Type _} (d : Distinction \u03b1) : (mark d).inside = d.outside := rfl\n@[simp] theorem mark_outside {\u03b1 : Type _} (d : Distinction \u03b1) : (mark d).outside = d.inside := rfl", "pos": {"x": 0.983507513999939, "y": 0.7469002604484558}, "pos3": {"x": 0.011321166530251503, "y": 0.5051800012588501, "z": 0.9837772846221924}}, {"id": "Numbers/Surreal/LoFDerivation.lean:GameDistinction", "name": "GameDistinction", "kind": "abbrev", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 51, "family": "Other", "snippet": "abbrev GameDistinction := Distinction (List PreGame)\n\nnamespace GameDistinction\n\n/-- Forget the `birth` field: a pregame is (left options, right options). -/", "pos": {"x": 0.9852412939071655, "y": 0.7452958822250366}, "pos3": {"x": 0.011408256366848946, "y": 0.5037932395935059, "z": 0.9807649850845337}}, {"id": "Numbers/Surreal/LoFDerivation.lean:ofPreGame", "name": "ofPreGame", "kind": "def", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 56, "family": "Other", "snippet": "def ofPreGame (g : PreGame) : GameDistinction :=\n  \u27e8g.L, g.R\u27e9\n\n/-- Rebuild a pregame from its distinction data, with `birth := 0` (raw `{L|R}` shape). -/\ndef toPreGameRaw (d : GameDistinction) : PreGame :=", "pos": {"x": 0.9893317222595215, "y": 0.7401458024978638}, "pos3": {"x": 0.008065413683652878, "y": 0.5037791132926941, "z": 0.9791105389595032}}, {"id": "Numbers/Surreal/LoFDerivation.lean:toPreGameRaw", "name": "toPreGameRaw", "kind": "def", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 60, "family": "Other", "snippet": "def toPreGameRaw (d : GameDistinction) : PreGame :=\n  { L := d.inside, R := d.outside, birth := 0 }\n\n/-- Rebuild a pregame from its distinction data using the canonical `PreGame.build`\n(computes a consistent birthday from children). -/", "pos": {"x": 0.9867807030677795, "y": 0.7435553669929504}, "pos3": {"x": 0.0118707325309515, "y": 0.5001109838485718, "z": 0.9842355251312256}}, {"id": "Numbers/Surreal/LoFDerivation.lean:toPreGame", "name": "toPreGame", "kind": "def", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 65, "family": "Other", "snippet": "def toPreGame (d : GameDistinction) : PreGame :=\n  PreGame.build d.inside d.outside\n\n@[simp] theorem toPreGameRaw_L (d : GameDistinction) : (toPreGameRaw d).L = d.inside := rfl\n@[simp] theorem toPreGameRaw_R (d : GameDistinction) : (toPreGameRaw d).R = d.outside := rfl", "pos": {"x": 0.9850061535835266, "y": 0.7419568300247192}, "pos3": {"x": 0.009908274747431278, "y": 0.5018100142478943, "z": 0.9829720854759216}}, {"id": "Numbers/Surreal/LoFDerivation.lean:distinction_pregame_equiv", "name": "distinction_pregame_equiv", "kind": "theorem", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 79, "family": "Other", "snippet": "theorem distinction_pregame_equiv (g : PreGame) :\n    (toPreGameRaw (ofPreGame g)).L = g.L \u2227 (toPreGameRaw (ofPreGame g)).R = g.R := by\n  exact \u27e8rfl, rfl\u27e9\n\nend GameDistinction", "pos": {"x": 0.9864976406097412, "y": 0.7432605624198914}, "pos3": {"x": 0.006700717844069004, "y": 0.5062123537063599, "z": 0.977466344833374}}, {"id": "Numbers/Surreal/LoFDerivation.lean:zero", "name": "zero", "kind": "abbrev", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 90, "family": "Other", "snippet": "abbrev zero : PreGame := SurrealCore.nullCut\n\nend SurrealCore.PreGame\n\nopen SurrealCore.PreGame", "pos": {"x": 0.9861447811126709, "y": 0.7386302351951599}, "pos3": {"x": 0.01033965963870287, "y": 0.5049800872802734, "z": 0.9799510836601257}}, {"id": "Numbers/Surreal/LoFDerivation.lean:void_is_zero", "name": "void_is_zero", "kind": "theorem", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 96, "family": "Other", "snippet": "theorem void_is_zero :\n    GameDistinction.toPreGameRaw ({ inside := ([] : List PreGame), outside := ([] : List PreGame) } : GameDistinction)\n      = (zero : PreGame) := by\n  rfl\n", "pos": {"x": 0.9912195205688477, "y": 0.7544042468070984}, "pos3": {"x": 0.003163200104609132, "y": 0.5061966776847839, "z": 0.9836775064468384}}, {"id": "Numbers/Surreal/LoFDerivation.lean:evalDistinction", "name": "evalDistinction", "kind": "def", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 109, "family": "Other", "snippet": "def evalDistinction {\u03b1 : Type _} [Inhabited \u03b1] {n : Nat} :\n    HeytingLean.LoF.LoFPrimary.Expr n \u2192 (Fin n \u2192 Distinction \u03b1) \u2192 Distinction \u03b1\n  | .void, _ => \u27e8default, default\u27e9\n  | .var i, \u03c1 => \u03c1 i\n  | .mark e, \u03c1 => Distinction.mark (evalDistinction e \u03c1)", "pos": {"x": 0.994509756565094, "y": 0.7439900636672974}, "pos3": {"x": 0.0039609153755009174, "y": 0.5040314197540283, "z": 0.9839193224906921}}, {"id": "Numbers/Surreal/LoFDerivation.lean:lof_distinction_is_surreal_constructor", "name": "lof_distinction_is_surreal_constructor", "kind": "theorem", "path": "Numbers/Surreal/LoFDerivation.lean", "line": 132, "family": "Other", "snippet": "theorem lof_distinction_is_surreal_constructor (L R : List PreGame) :\n    GameDistinction.toPreGameRaw ({ inside := L, outside := R } : GameDistinction)\n      = ({ L := L, R := R, birth := 0 } : PreGame) := by\n  rfl\n", "pos": {"x": 0.9951339960098267, "y": 0.7443870306015015}, "pos3": {"x": 0.005315035115927458, "y": 0.5125771760940552, "z": 0.982393741607666}}, {"id": "Quantum/OML/Core.lean:OrthocomplementedLattice", "name": "OrthocomplementedLattice", "kind": "structure", "path": "Quantum/OML/Core.lean", "line": 13, "family": "Other", "snippet": "class OrthocomplementedLattice (\u03b1 : Type _)\n  extends Lattice \u03b1, BoundedOrder \u03b1 where\n  compl : \u03b1 \u2192 \u03b1\n  involutive : \u2200 a, compl (compl a) = a\n  antitone : \u2200 {a b}, a \u2264 b \u2192 compl b \u2264 compl a", "pos": {"x": 0.9106131792068481, "y": 0.4989576041698456}, "pos3": {"x": 0.2909969985485077, "y": 0.005181221291422844, "z": 0.6981443166732788}}, {"id": "Quantum/OML/Core.lean:compl_antitone", "name": "compl_antitone", "kind": "theorem", "path": "Quantum/OML/Core.lean", "line": 32, "family": "Other", "snippet": "lemma compl_antitone {a b : \u03b1} (h : a \u2264 b) :\n    OrthocomplementedLattice.compl b \u2264 OrthocomplementedLattice.compl a :=\n  OrthocomplementedLattice.antitone (\u03b1 := \u03b1) (a := a) (b := b) h\n\n@[simp] lemma compl_le_iff_le_compl {a b : \u03b1} :", "pos": {"x": 0.9037572741508484, "y": 0.4925162196159363}, "pos3": {"x": 0.28926172852516174, "y": 0.007487161085009575, "z": 0.6975735425949097}}, {"id": "Quantum/OML/Core.lean:OrthomodularLattice", "name": "OrthomodularLattice", "kind": "structure", "path": "Quantum/OML/Core.lean", "line": 118, "family": "Other", "snippet": "class OrthomodularLattice (\u03b1 : Type _) [OrthocomplementedLattice \u03b1] : Prop where\n  orthomodular :\n    \u2200 {a b : \u03b1}, a \u2264 b \u2192\n      b = a \u2294 (OrthocomplementedLattice.compl a \u2293 b)\n", "pos": {"x": 0.9087551832199097, "y": 0.4976799786090851}, "pos3": {"x": 0.29401251673698425, "y": 0.0046274857595562935, "z": 0.7000685930252075}}, {"id": "Quantum/OML/Core.lean:eq_inf_sup_compl_of_le", "name": "eq_inf_sup_compl_of_le", "kind": "theorem", "path": "Quantum/OML/Core.lean", "line": 127, "family": "Other", "snippet": "lemma eq_inf_sup_compl_of_le {a b : \u03b1} (h : a \u2264 b) :\n    a = b \u2293 (a \u2294 OrthocomplementedLattice.compl b) := by\n  have hcompl :\n      OrthocomplementedLattice.compl b \u2264 OrthocomplementedLattice.compl a :=\n    OrthocomplementedLattice.compl_antitone (\u03b1 := \u03b1) h", "pos": {"x": 0.9073245525360107, "y": 0.4953565299510956}, "pos3": {"x": 0.2904110550880432, "y": 0.007825610227882862, "z": 0.6967998743057251}}, {"id": "Quantum/OML/Core.lean:proj_id_of_le", "name": "proj_id_of_le", "kind": "theorem", "path": "Quantum/OML/Core.lean", "line": 145, "family": "Other", "snippet": "lemma proj_id_of_le {a x : \u03b1} (h : x \u2264 a) :\n    a \u2293 (OrthocomplementedLattice.compl a \u2294 x) = x := by\n  have := eq_inf_sup_compl_of_le (a := x) (b := a) h\n  simpa [sup_comm] using this.symm\n", "pos": {"x": 0.9058371782302856, "y": 0.4972967803478241}, "pos3": {"x": 0.29378044605255127, "y": 0.0023264812771230936, "z": 0.6957055330276489}}, {"id": "Quantum/OML/Sasaki.lean:instOrthocomplementedLatticeOfBoolean", "name": "instOrthocomplementedLatticeOfBoolean", "kind": "instance", "path": "Quantum/OML/Sasaki.lean", "line": 23, "family": "Other", "snippet": "instance instOrthocomplementedLatticeOfBoolean (\u03b1 : Type _) [BooleanAlgebra \u03b1] :\n    OrthocomplementedLattice \u03b1 where\n  compl := compl\n  involutive := by intro a; simp\n  antitone := by", "pos": {"x": 0.9101218581199646, "y": 0.49345773458480835}, "pos3": {"x": 0.2880120277404785, "y": 0.004587744828313589, "z": 0.7004755735397339}}, {"id": "Quantum/OML/Sasaki.lean:instOrthomodularLatticeOfBoolean", "name": "instOrthomodularLatticeOfBoolean", "kind": "instance", "path": "Quantum/OML/Sasaki.lean", "line": 35, "family": "Other", "snippet": "instance instOrthomodularLatticeOfBoolean (\u03b1 : Type _) [BooleanAlgebra \u03b1] :\n    OrthomodularLattice \u03b1 where\n  orthomodular := by\n    intro a b h\n    -- Boolean orthomodularity collapses to the distributive identity.", "pos": {"x": 0.907595157623291, "y": 0.49674513936042786}, "pos3": {"x": 0.2893786132335663, "y": 0.007100918795913458, "z": 0.6990237832069397}}, {"id": "Quantum/OML/Sasaki.lean:sasakiProj_monotone_right", "name": "sasakiProj_monotone_right", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 154, "family": "Other", "snippet": "lemma sasakiProj_monotone_right (a : \u03b1) : Monotone fun b => sasakiProj a b := by\n  intro b\u2081 b\u2082 h\n  dsimp [sasakiProj]\n  exact inf_le_inf_left _ (sup_le_sup_left h _)\n", "pos": {"x": 0.9116082191467285, "y": 0.5010091066360474}, "pos3": {"x": 0.2859433889389038, "y": 0.011346816085278988, "z": 0.7002719044685364}}, {"id": "Quantum/OML/Sasaki.lean:sasakiHook_monotone_right", "name": "sasakiHook_monotone_right", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 160, "family": "Other", "snippet": "lemma sasakiHook_monotone_right (a : \u03b1) : Monotone fun b => sasakiHook a b := by\n  intro b\u2081 b\u2082 h\n  dsimp [sasakiHook]\n  exact sup_le_sup_left (inf_le_inf_left _ h) _\n", "pos": {"x": 0.9073660373687744, "y": 0.49365177750587463}, "pos3": {"x": 0.28657346963882446, "y": 0.003008661326020956, "z": 0.695565402507782}}, {"id": "Quantum/OML/Sasaki.lean:sasakiProj_id_of_le", "name": "sasakiProj_id_of_le", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 190, "family": "Other", "snippet": "lemma sasakiProj_id_of_le {a b : \u03b1} (h : b \u2264 a) : sasakiProj a b = b := by\n  have := eq_inf_sup_compl_of_le (a := a) (b := b) h\n  have h' : a \u2293 (OrthocomplementedLattice.compl a \u2294 b) = b := by\n    have h'' := this.symm\n    simpa [sup_comm] using h''", "pos": {"x": 0.907619833946228, "y": 0.4961378574371338}, "pos3": {"x": 0.2895333468914032, "y": 0.002179183531552553, "z": 0.6957164406776428}}, {"id": "Quantum/OML/Sasaki.lean:sasakiProj_of_le", "name": "sasakiProj_of_le", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 198, "family": "Other", "snippet": "lemma sasakiProj_of_le {a b : \u03b1} (h : b \u2264 a) : a \u25b7 b = b :=\n  sasakiProj_id_of_le (a := a) (b := b) h\n\n/-- Weak modus ponens for the Sasaki hook: `a \u2293 (a \u21d2\u209b b) \u2264 b` in any orthomodular lattice. -/\ntheorem sasaki_mp (a b : \u03b1) : a \u2293 sasakiHook a b \u2264 b := by", "pos": {"x": 0.9068384170532227, "y": 0.4950281083583832}, "pos3": {"x": 0.290295273065567, "y": 0.009667513892054558, "z": 0.7013347148895264}}, {"id": "Quantum/OML/Sasaki.lean:sasaki_mp", "name": "sasaki_mp", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 202, "family": "Other", "snippet": "theorem sasaki_mp (a b : \u03b1) : a \u2293 sasakiHook a b \u2264 b := by\n  calc\n    a \u2293 sasakiHook a b = sasakiProj a (a \u2293 b) := by rfl\n    _ = a \u2293 b :=\n      sasakiProj_id_of_le (a := a) (b := a \u2293 b) (inf_le_left : a \u2293 b \u2264 a)", "pos": {"x": 0.9057270288467407, "y": 0.49394211173057556}, "pos3": {"x": 0.2890078127384186, "y": 0.0026860565412789583, "z": 0.7039092183113098}}, {"id": "Quantum/OML/Sasaki.lean:sasaki_weak_mp", "name": "sasaki_weak_mp", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 209, "family": "Other", "snippet": "lemma sasaki_weak_mp (a b : \u03b1) : a \u2293 sasakiHook a b \u2264 b :=\n  sasaki_mp (a := a) (b := b)\n\nend Orthomodular\n", "pos": {"x": 0.9129178524017334, "y": 0.4951951205730438}, "pos3": {"x": 0.2911655604839325, "y": 0.00644873920828104, "z": 0.7028984427452087}}, {"id": "Quantum/OML/Sasaki.lean:sasakiHook_eq_classical", "name": "sasakiHook_eq_classical", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 219, "family": "Other", "snippet": "lemma sasakiHook_eq_classical (a b : \u03b1) : sasakiHook a b = a\u1d9c \u2294 b := by\n  -- specialize the orthocomplemented instance to the Boolean one\n  let _ := instOrthocomplementedLatticeOfBoolean (\u03b1 := \u03b1)\n  have h := sup_inf_left (a := a\u1d9c) (b := a) (c := b)\n  calc", "pos": {"x": 0.9110749959945679, "y": 0.4956287145614624}, "pos3": {"x": 0.28891071677207947, "y": 0.010593638755381107, "z": 0.7028049230575562}}, {"id": "Quantum/OML/Sasaki.lean:sasakiHook_le_nucleus_imp", "name": "sasakiHook_le_nucleus_imp", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 246, "family": "Other", "snippet": "lemma sasakiHook_le_nucleus_imp (n : Nucleus \u03b1) (a b : \u03b1) :\n    sasakiHook a b \u2264 n (OrthocomplementedLattice.compl a \u2294 b) :=\n  (sasakiHook_le_imp_base (a := a) (b := b)).trans\n    (Nucleus.le_apply (n := n) (x := OrthocomplementedLattice.compl a \u2294 b))\n", "pos": {"x": 0.9115263223648071, "y": 0.502575695514679}, "pos3": {"x": 0.29111969470977783, "y": 0.002712247660383582, "z": 0.7050099968910217}}, {"id": "Quantum/OML/Sasaki.lean:sasakiHook_closure_eq_classical", "name": "sasakiHook_closure_eq_classical", "kind": "theorem", "path": "Quantum/OML/Sasaki.lean", "line": 260, "family": "Other", "snippet": "lemma sasakiHook_closure_eq_classical (n : Nucleus \u03b1) (a b : \u03b1) :\n    n (sasakiHook a b) = n (OrthocomplementedLattice.compl a \u2294 b) := by\n  have h : sasakiHook a b = OrthocomplementedLattice.compl a \u2294 b := by\n    -- On Boolean algebras `a\u1d9c` is the orthocomplement.\n    simpa using (sasakiHook_eq_clas", "pos": {"x": 0.9051519632339478, "y": 0.5012421607971191}, "pos3": {"x": 0.29243552684783936, "y": 0.0, "z": 0.6954168677330017}}, {"id": "Quantum/Translate/Modality.lean:Modality", "name": "Modality", "kind": "structure", "path": "Quantum/Translate/Modality.lean", "line": 9, "family": "Other", "snippet": "structure Modality (\u03b1 : Type _) [CompleteLattice \u03b1] where\n  J : Nucleus \u03b1\n  preserves_top : J \u22a4 = (\u22a4 : \u03b1)\n\nnamespace Modality", "pos": {"x": 0.4886487126350403, "y": 0.2263166904449463}, "pos3": {"x": 0.5470101833343506, "y": 0.35986271500587463, "z": 0.40026918053627014}}, {"id": "Quantum/Translate/Modality.lean:close", "name": "close", "kind": "def", "path": "Quantum/Translate/Modality.lean", "line": 17, "family": "Other", "snippet": "def close : \u03b1 \u2192 \u03b1 := M.J\n\n@[simp] lemma close_apply (a : \u03b1) : M.close a = M.J a := rfl\n\n@[simp] lemma idempotent (a : \u03b1) : M.close (M.close a) = M.close a := M.J.idempotent _", "pos": {"x": 0.4902643859386444, "y": 0.2272973656654358}, "pos3": {"x": 0.5436469912528992, "y": 0.35731878876686096, "z": 0.4015405774116516}}, {"id": "Quantum/Translate/Modality.lean:map_sup", "name": "map_sup", "kind": "theorem", "path": "Quantum/Translate/Modality.lean", "line": 26, "family": "Other", "snippet": "lemma map_sup (a b : \u03b1) : M.close (a \u2294 b) = M.close (M.close a \u2294 M.close b) := by\n  classical\n  simpa using (M.J.toClosureOperator.closure_sup_closure (x := a) (y := b)).symm\n\n/-- Closing a right summand before joining does not change the overall closure. -/", "pos": {"x": 0.4865034818649292, "y": 0.22977639734745026}, "pos3": {"x": 0.5485479831695557, "y": 0.3586570620536804, "z": 0.3981552720069885}}, {"id": "Quantum/Translate/Modality.lean:sup_close_right", "name": "sup_close_right", "kind": "theorem", "path": "Quantum/Translate/Modality.lean", "line": 31, "family": "Other", "snippet": "lemma sup_close_right (M : Modality \u03b1) (x y : \u03b1) :\n    M.close (x \u2294 M.close y) = M.close (x \u2294 y) := by\n  apply le_antisymm\n  \u00b7\n    -- `x \u2294 M.close y` already lies under the desired closure.", "pos": {"x": 0.48897308111190796, "y": 0.22586366534233093}, "pos3": {"x": 0.5439187288284302, "y": 0.35756486654281616, "z": 0.4011874198913574}}, {"id": "Quantum/Translate/Modality.lean:sup_close_left", "name": "sup_close_left", "kind": "theorem", "path": "Quantum/Translate/Modality.lean", "line": 54, "family": "Other", "snippet": "lemma sup_close_left (M : Modality \u03b1) (x y : \u03b1) :\n    M.close (M.close x \u2294 y) = M.close (x \u2294 y) := by\n  simpa [sup_comm] using (M.sup_close_right (x := y) (y := x))\n\n/-! ### Identity modality -/", "pos": {"x": 0.48506394028663635, "y": 0.22691158950328827}, "pos3": {"x": 0.5470441579818726, "y": 0.35892006754875183, "z": 0.40010184049606323}}, {"id": "Quantum/Translate/Core.lean:QLMap", "name": "QLMap", "kind": "structure", "path": "Quantum/Translate/Core.lean", "line": 18, "family": "Other", "snippet": "structure QLMap (\u03b2 \u03b1 : Type _)\n  [HeytingLean.Quantum.OML.OrthocomplementedLattice \u03b2]\n  [HeytingLean.Quantum.OML.OrthomodularLattice \u03b2] [CompleteLattice \u03b1] where\n  M : Modality \u03b1\n  tr : \u03b2 \u2192 \u03b1", "pos": {"x": 0.4749304950237274, "y": 0.2507810592651367}, "pos3": {"x": 0.552648663520813, "y": 0.38371744751930237, "z": 0.4086957573890686}}, {"id": "Quantum/Translate/Core.lean:tr_sup_le", "name": "tr_sup_le", "kind": "theorem", "path": "Quantum/Translate/Core.lean", "line": 34, "family": "Other", "snippet": "lemma tr_sup_le (x y : \u03b2) : F.tr (x \u2294 y) \u2264 F.M.close (F.tr x \u2294 F.tr y) :=\n  (F.map_sup_le x y).trans_eq rfl\n\nend QLMap\n", "pos": {"x": 0.47438132762908936, "y": 0.2509526014328003}, "pos3": {"x": 0.5551996827125549, "y": 0.3866075277328491, "z": 0.41130509972572327}}, {"id": "Quantum/Translate/Core.lean:sasakiHook_le_translated_nucleus_imp_raw", "name": "sasakiHook_le_translated_nucleus_imp_raw", "kind": "theorem", "path": "Quantum/Translate/Core.lean", "line": 75, "family": "Other", "snippet": "lemma sasakiHook_le_translated_nucleus_imp_raw (a b : \u03b2) :\n    F.tr (sasakiHook a b)\n      \u2264 F.M.J (F.tr (OrthocomplementedLattice.compl a) \u2294 F.tr b) := by\n  -- push Sasaki hook through the translation using join subadditivity\n  have h_sup : F.tr (sasakiHook a b)", "pos": {"x": 0.4746280908584595, "y": 0.2531358301639557}, "pos3": {"x": 0.5533238649368286, "y": 0.3847188949584961, "z": 0.4093922972679138}}, {"id": "Quantum/Translate/Core.lean:ComplPreserving", "name": "ComplPreserving", "kind": "structure", "path": "Quantum/Translate/Core.lean", "line": 114, "family": "Other", "snippet": "class ComplPreserving (F : QLMap \u03b2 \u03b1) : Prop where\n  compl_closed :\n    \u2200 a : \u03b2,\n      F.M.J (F.tr (OrthocomplementedLattice.compl a))\n        = F.M.J ((F.tr a)\u1d9c)", "pos": {"x": 0.4737648665904999, "y": 0.25218257308006287}, "pos3": {"x": 0.5538013577461243, "y": 0.38518592715263367, "z": 0.4098860025405884}}, {"id": "Quantum/Translate/Core.lean:sasakiHook_le_translated_nucleus_imp", "name": "sasakiHook_le_translated_nucleus_imp", "kind": "theorem", "path": "Quantum/Translate/Core.lean", "line": 122, "family": "Other", "snippet": "lemma sasakiHook_le_translated_nucleus_imp\n    (hCompl : ComplPreserving F) (a b : \u03b2) :\n    F.tr (sasakiHook a b) \u2264 F.M.J ((F.tr a)\u1d9c \u2294 F.tr b) := by\n  -- start from the raw bridge\n  have h_raw := sasakiHook_le_translated_nucleus_imp_raw (F := F) (a := a) (b := b)", "pos": {"x": 0.4723055958747864, "y": 0.25241339206695557}, "pos3": {"x": 0.5550251603126526, "y": 0.3837307095527649, "z": 0.41118913888931274}}, {"id": "Quantum/Translate/Omega.lean:Omega", "name": "Omega", "kind": "abbrev", "path": "Quantum/Translate/Omega.lean", "line": 15, "family": "Other", "snippet": "abbrev Omega (M : Modality \u03b1) : Type _ := M.J.toSublocale\n\nnamespace Omega\n\nvariable (M : Modality \u03b1)", "pos": {"x": 0.4861864745616913, "y": 0.23488174378871918}, "pos3": {"x": 0.5508666038513184, "y": 0.36552149057388306, "z": 0.4005407691001892}}, {"id": "Quantum/Translate/Omega.lean:inf", "name": "inf", "kind": "def", "path": "Quantum/Translate/Omega.lean", "line": 32, "family": "Other", "snippet": "def inf (x y : Omega M) : Omega M := x \u2293 y\n\n/-- Supremum in `\u03a9_M`. -/\ndef sup (x y : Omega M) : Omega M := x \u2294 y\n", "pos": {"x": 0.48272383213043213, "y": 0.2335694283246994}, "pos3": {"x": 0.5482466220855713, "y": 0.36349162459373474, "z": 0.40400275588035583}}, {"id": "Quantum/Translate/Omega.lean:sup", "name": "sup", "kind": "def", "path": "Quantum/Translate/Omega.lean", "line": 35, "family": "Other", "snippet": "def sup (x y : Omega M) : Omega M := x \u2294 y\n\n/-- Top element in `\u03a9_M`. -/\ndef top : Omega M := \u22a4\n", "pos": {"x": 0.4844423830509186, "y": 0.23390896618366241}, "pos3": {"x": 0.5480771660804749, "y": 0.3665040135383606, "z": 0.40131503343582153}}, {"id": "Quantum/Translate/Omega.lean:top", "name": "top", "kind": "def", "path": "Quantum/Translate/Omega.lean", "line": 38, "family": "Other", "snippet": "def top : Omega M := \u22a4\n\n/-- Bottom element in `\u03a9_M`. -/\ndef bot : Omega M := \u22a5\n", "pos": {"x": 0.4815380871295929, "y": 0.22960536181926727}, "pos3": {"x": 0.5502495169639587, "y": 0.3640941083431244, "z": 0.40570130944252014}}, {"id": "Quantum/Translate/Omega.lean:bot", "name": "bot", "kind": "def", "path": "Quantum/Translate/Omega.lean", "line": 41, "family": "Other", "snippet": "def bot : Omega M := \u22a5\n\nsection Heyting\n\nvariable [HeytingAlgebra \u03b1]", "pos": {"x": 0.4843120872974396, "y": 0.2330016791820526}, "pos3": {"x": 0.5485582947731018, "y": 0.3650394082069397, "z": 0.40469107031822205}}, {"id": "Quantum/Translate/Omega.lean:imp", "name": "imp", "kind": "def", "path": "Quantum/Translate/Omega.lean", "line": 48, "family": "Other", "snippet": "def imp (x y : Omega M) : Omega M := x \u21e8 y\n\nend Heyting\n\n/-- In the Heyting core `\u03a9_{T.M}`, the translated Sasaki hook lies below the Heyting implication.", "pos": {"x": 0.4824569821357727, "y": 0.2330135554075241}, "pos3": {"x": 0.546317458152771, "y": 0.36771154403686523, "z": 0.4022790193557739}}, {"id": "Quantum/Translate/Omega.lean:sasakiHook_le_himp", "name": "sasakiHook_le_himp", "kind": "theorem", "path": "Quantum/Translate/Omega.lean", "line": 54, "family": "Other", "snippet": "lemma sasakiHook_le_himp\n    {\u03b2 : Type _} {\u03b1 : Type _}\n    [HeytingLean.Quantum.OML.OrthocomplementedLattice \u03b2]\n    [HeytingLean.Quantum.OML.OrthomodularLattice \u03b2]\n    [Order.Frame \u03b1] [HasCompl \u03b1]", "pos": {"x": 0.48442280292510986, "y": 0.2337813824415207}, "pos3": {"x": 0.5463787317276001, "y": 0.3663959205150604, "z": 0.3993585407733917}}], "edges": [[15, 30], [55, 66], [67, 68], [107, 113], [147, 149], [70, 73], [159, 160], [139, 154], [0, 5], [210, 214], [129, 137], [74, 201], [132, 133], [151, 155], [192, 193], [184, 189], [41, 42], [150, 205], [81, 96], [2, 41], [3, 6], [74, 75], [122, 124], [106, 107], [166, 167], [174, 180], [158, 163], [15, 16], [7, 12], [47, 48], [188, 191], [199, 200], [29, 36], [48, 49], [80, 81], [129, 132], [121, 128], [100, 105], [140, 141], [132, 137], [121, 137], [92, 110], [10, 31], [81, 82], [54, 65], [203, 206], [162, 174], [2, 45], [165, 170], [22, 23], [95, 102], [74, 79], [114, 115], [187, 194], [206, 207], [158, 167], [47, 52], [55, 65], [96, 103], [107, 112], [147, 148], [139, 153], [210, 213], [121, 123], [80, 103], [172, 177], [151, 154], [184, 188], [102, 109], [184, 197], [150, 204], [3, 5], [77, 201], [14, 23], [143, 146], [17, 34], [128, 130], [120, 126], [58, 62], [160, 180], [191, 195], [21, 40], [80, 98], [161, 172], [205, 206], [54, 55], [102, 104], [91, 113], [146, 147], [165, 169], [87, 88], [127, 133], [106, 110], [76, 78], [198, 202], [47, 51], [88, 89], [136, 138], [5, 45], [168, 170], [168, 179], [180, 181], [139, 152], [77, 79], [90, 107], [101, 107], [80, 84], [121, 122], [20, 39], [172, 176], [213, 214], [91, 99], [131, 135], [154, 155], [24, 27], [13, 36], [38, 209], [84, 96], [143, 145], [84, 105], [95, 105], [57, 60], [9, 20], [68, 69], [46, 69], [128, 129], [157, 165], [160, 161], [209, 212], [89, 119], [42, 44], [160, 179], [82, 98], [119, 147], [142, 149], [182, 194], [83, 99], [4, 44], [91, 112], [183, 186], [94, 108], [194, 195], [38, 204], [64, 67], [43, 44], [16, 27], [38, 213], [127, 132], [49, 51], [187, 192], [76, 77], [28, 37], [109, 111], [9, 33], [168, 169], [98, 101], [90, 97], [90, 106], [142, 144], [190, 193], [182, 189], [91, 98], [131, 134], [83, 103], [175, 177], [183, 190], [24, 26], [53, 62], [32, 39], [16, 22], [24, 35], [124, 131], [164, 167], [176, 178], [46, 50], [208, 210], [9, 10], [17, 23], [57, 59], [65, 72], [156, 181], [97, 104], [186, 191], [157, 164], [189, 196], [209, 211], [70, 114], [42, 43], [171, 175], [134, 135], [90, 110], [119, 146], [182, 184], [31, 33], [12, 29], [23, 29], [71, 115], [75, 76], [123, 125], [4, 43], [183, 185], [53, 57], [38, 203], [93, 102], [16, 26], [93, 111], [145, 149], [108, 109], [156, 158], [208, 214], [65, 67], [49, 50], [201, 202], [8, 36], [50, 51], [63, 70], [82, 83], [163, 166], [142, 143], [190, 192], [182, 188], [182, 197], [115, 116], [1, 5], [175, 176], [53, 61], [93, 97], [16, 21], [56, 57], [64, 70], [16, 30], [116, 117], [164, 166], [46, 49], [208, 209], [57, 58], [18, 39], [8, 13], [130, 137], [75, 201], [97, 112], [27, 35], [11, 18], [189, 195], [19, 40], [171, 174], [0, 45], [163, 170], [31, 32], [141, 151], [104, 111], [144, 147], [123, 124], [204, 207], [73, 114], [53, 56], [85, 88], [64, 65], [174, 175], [56, 61], [145, 148], [156, 157], [185, 193], [5, 6], [156, 166], [86, 89], [59, 72], [130, 132], [118, 148], [71, 73], [100, 109], [63, 69], [140, 154], [11, 40], [163, 165], [171, 178], [200, 214], [12, 23], [152, 155], [125, 138], [141, 155], [1, 4], [122, 123], [185, 188], [18, 20], [7, 29], [126, 138], [8, 12], [19, 21], [118, 143], [159, 181], [100, 104], [63, 64], [92, 109], [171, 173], [41, 45], [163, 169], [203, 205], [2, 44], [144, 146], [204, 206], [74, 78], [14, 36], [85, 87], [3, 45], [158, 166], [166, 179], [185, 192], [26, 28], [55, 64], [59, 62], [26, 37], [18, 33], [7, 33], [47, 69], [70, 71], [126, 133], [0, 3], [48, 52], [210, 212], [19, 25], [11, 21], [92, 104], [140, 153], [151, 153], [163, 164], [62, 72], [184, 196], [211, 213], [150, 203], [81, 103], [173, 177], [152, 154], [14, 22], [34, 37], [196, 197], [66, 69], [73, 117], [122, 131], [174, 178], [87, 119], [185, 187], [18, 19], [158, 179], [188, 189], [159, 162], [191, 194], [129, 130], [11, 16], [121, 126], [10, 20], [92, 108], [184, 191], [41, 44], [203, 204], [150, 207], [2, 43], [165, 168], [144, 145], [162, 181], [14, 17], [22, 30], [95, 100], [74, 77], [143, 149], [122, 126], [85, 86], [195, 196], [122, 135], [158, 165], [198, 201], [177, 178], [7, 23], [55, 72], [47, 68], [118, 119], [120, 138], [139, 151], [77, 78], [21, 25], [199, 202], [0, 2], [48, 51], [6, 45], [80, 83], [169, 170], [74, 198], [92, 94], [121, 130], [169, 179], [172, 175], [140, 152], [151, 152], [184, 186], [10, 33], [91, 107], [81, 84], [54, 67], [184, 195], [25, 40], [51, 52], [173, 176], [125, 136], [143, 144], [14, 30], [66, 68], [95, 104], [114, 117], [158, 160], [7, 9], [55, 67], [96, 105], [99, 101], [128, 137], [120, 133], [58, 60], [188, 197], [139, 155], [191, 193], [121, 125], [80, 96], [121, 134], [10, 19], [80, 105], [161, 179], [54, 62], [2, 42], [125, 131], [165, 167], [162, 180], [124, 135], [143, 148], [158, 164], [198, 200], [17, 36], [128, 132], [139, 141], [188, 192], [191, 197], [80, 82], [129, 133], [91, 97], [54, 57], [10, 32], [54, 66], [202, 211], [77, 198], [84, 103], [176, 177], [17, 22], [65, 71], [9, 18], [187, 195], [209, 210], [58, 59], [157, 181], [191, 192], [142, 147], [121, 124], [71, 114], [10, 18], [91, 101], [54, 61], [4, 42], [94, 106], [32, 33], [183, 193], [13, 29], [16, 25], [165, 166], [1, 45], [124, 134], [143, 147], [208, 213], [187, 190], [57, 62], [198, 199], [28, 35], [97, 107], [157, 158], [120, 127], [139, 140], [209, 214], [120, 136], [70, 117], [98, 99], [61, 68], [190, 191], [101, 113], [39, 40], [90, 113], [182, 196], [161, 173], [172, 173], [205, 207], [75, 79], [54, 56], [102, 105], [53, 60], [94, 110], [146, 148], [164, 165], [87, 89], [85, 119], [46, 48], [17, 30], [97, 102], [76, 79], [19, 39], [98, 103], [50, 63], [20, 31], [2, 4], [20, 40], [4, 41], [183, 192], [24, 28], [16, 24], [56, 60], [35, 37], [24, 37], [93, 109], [145, 147], [127, 129], [156, 165], [46, 52], [86, 88], [127, 138], [9, 12], [208, 212], [57, 61], [97, 106], [157, 166], [118, 147], [160, 162], [30, 34], [71, 72], [209, 213], [70, 116], [42, 45], [90, 94], [171, 177], [12, 13], [82, 99], [90, 112], [119, 148], [182, 195], [104, 105], [141, 154], [75, 78], [1, 3], [212, 214], [13, 14], [123, 136], [4, 45], [13, 23], [53, 59], [93, 95], [93, 104], [108, 111], [78, 79], [49, 52], [186, 188], [75, 199], [19, 20], [159, 180], [186, 197], [86, 119], [8, 29], [11, 25], [163, 168], [119, 143], [142, 145], [82, 103], [112, 113], [104, 109], [204, 205], [53, 54], [175, 178], [145, 146], [185, 191], [26, 27], [156, 164], [46, 51], [18, 32], [86, 87], [167, 179], [186, 192], [159, 175], [27, 28], [118, 146], [11, 20], [48, 69], [63, 67], [70, 115], [171, 176], [200, 212], [211, 212], [38, 150], [23, 30], [141, 153], [152, 153], [75, 77], [1, 2], [123, 126], [144, 149], [22, 34], [212, 213], [73, 116], [53, 58], [174, 177], [185, 186], [15, 22], [108, 110], [126, 127], [159, 161], [126, 136], [88, 119], [0, 6], [170, 179], [100, 111], [41, 43], [163, 167], [150, 206], [115, 117], [1, 6], [74, 76], [122, 125], [14, 34], [122, 134], [56, 58], [7, 13], [185, 190], [15, 26], [59, 60], [15, 35], [26, 35], [18, 31], [199, 201], [0, 1], [48, 50], [11, 19], [92, 93], [92, 102], [140, 151], [200, 202], [92, 111], [184, 185], [200, 211], [184, 194], [81, 83], [203, 207], [125, 126], [173, 175], [141, 152], [125, 135], [144, 148], [66, 67], [73, 115], [114, 116], [85, 89], [174, 176], [7, 8]]};
