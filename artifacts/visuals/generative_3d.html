<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Generative Stack — 3D Proof Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; overflow: hidden; background:#0b0f14; color:#e6eef7; font: 13px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      #ui { position: fixed; top: 12px; left: 12px; right: 12px; display:flex; gap: 10px; align-items: center; z-index: 10; }
      .panel { background: rgba(15,23,33,0.92); border: 1px solid #1c2a3a; border-radius: 10px; padding: 10px 12px; backdrop-filter: blur(6px); }
      input[type="text"]{ width: 360px; max-width: 60vw; background:#0b1320; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; outline:none; }
      label { user-select:none; }
      button { background:#132033; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; cursor:pointer; }
      button:hover { background:#182a42; }
      #tip { position: fixed; pointer-events:none; z-index: 20; padding: 6px 8px; border-radius: 8px; background: rgba(0,0,0,0.75); border:1px solid rgba(255,255,255,0.10); display:none; max-width: 56vw; }
      #details { position: fixed; right: 12px; bottom: 12px; width: min(520px, calc(100vw - 24px)); max-height: 45vh; overflow:auto; white-space: pre-wrap; }
      #details h3 { margin: 0 0 8px; font-size: 14px; }
      .muted { color:#b8c7d9; }
      .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
      a { color:#8ab4f8; text-decoration:none; }
      a:hover{ text-decoration:underline; }
      code { background:#0b1320; border:1px solid #24364a; border-radius: 6px; padding:1px 6px; }
      #container { width: 100vw; height: 100vh; }
    </style>
  </head>
  <body>
    <div id="ui" class="row">
      <div class="panel row">
        <a href="../../index.html">&larr; index</a>
        <input id="q" type="text" placeholder="Search declarations (substring)..." />
        <label><input id="showEdges" type="checkbox" checked /> edges</label>
        <span id="edgeCount" class="muted"></span>
        <button id="reset">Reset View</button>
      </div>
      <div class="panel muted">Rotate: drag · Zoom: wheel · Select: click</div>
    </div>
    <div id="tip"></div>
    <div id="details" class="panel" style="display:none"></div>
    <div id="container"></div>

    <script src="./generative_proofs_data.js"></script>
    <script>
      ;(() => {
        const data = window.GENERATIVE_PROOFS || { items: [], edges: [] }
        const items = data.items || []
        const edges = data.edges || []

        const colorForFamily = (fam) => {
          const map = {
            'LoF': 0x6c5ce7,
            'Eigenform': 0xe17055,
            'Lawvere': 0xe94560,
            'Surreal': 0x0984e3,
            'Combinator': 0xfd79a8,
            'Ratchet': 0x00b894,
            'Quantum': 0x9b59b6,
            'HoTT': 0xf39c12,
            'Bauer': 0xe67e22,
            'Test': 0x636e72
          }
          return map[fam] || 0x90a4ae
        }

        // Scene setup
        const container = document.getElementById('container')
        const scene = new THREE.Scene()
        scene.background = new THREE.Color(0x0b0f14)

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(2, 2, 2)

        const renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setPixelRatio(window.devicePixelRatio)
        container.appendChild(renderer.domElement)

        const controls = new THREE.OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.05

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6)
        scene.add(ambientLight)
        const pointLight = new THREE.PointLight(0xffffff, 0.8)
        pointLight.position.set(5, 5, 5)
        scene.add(pointLight)

        // Create nodes
        const nodeGroup = new THREE.Group()
        const nodeMeshes = []
        // Slightly smaller nodes help edges remain visible in dense clusters.
        const nodeGeometry = new THREE.SphereGeometry(0.015, 16, 16)

        for (let i = 0; i < items.length; i++) {
          const it = items[i]
          const p = it.pos3 || { x: 0.5, y: 0.5, z: 0.5 }
          const material = new THREE.MeshLambertMaterial({ color: colorForFamily(it.family) })
          const mesh = new THREE.Mesh(nodeGeometry, material)
          mesh.position.set(p.x - 0.5, p.y - 0.5, p.z - 0.5)
          mesh.userData = { index: i }
          nodeMeshes.push(mesh)
          nodeGroup.add(mesh)
        }
        scene.add(nodeGroup)

        // Create edges (tubes) as an instanced mesh so edges are clearly visible even when
        // WebGL line widths are clamped to 1px.
        const edgeGroup = new THREE.Group()
        const edgeRadius = 0.0025
        const edgeGeom = new THREE.CylinderGeometry(edgeRadius, edgeRadius, 1.0, 6, 1, true)
        const edgeMat = new THREE.MeshBasicMaterial({ color: 0xf2f8ff, opacity: 0.45, transparent: true, depthTest: false })

        const validEdges = []
        for (const [i, j] of edges) {
          const a = items[i]?.pos3
          const b = items[j]?.pos3
          if (!a || !b) continue
          validEdges.push([i, j])
        }

        const edgeMesh = new THREE.InstancedMesh(edgeGeom, edgeMat, validEdges.length)
        edgeMesh.frustumCulled = false
        edgeMesh.renderOrder = 0

        const up = new THREE.Vector3(0, 1, 0)
        const tmpPos = new THREE.Vector3()
        const tmpQuat = new THREE.Quaternion()
        const tmpScale = new THREE.Vector3()
        const tmpMat4 = new THREE.Matrix4()

        for (let k = 0; k < validEdges.length; k++) {
          const [i, j] = validEdges[k]
          const a = items[i].pos3
          const b = items[j].pos3
          const p1 = new THREE.Vector3(a.x - 0.5, a.y - 0.5, a.z - 0.5)
          const p2 = new THREE.Vector3(b.x - 0.5, b.y - 0.5, b.z - 0.5)
          const dir = p2.clone().sub(p1)
          const len = dir.length()
          if (len < 1e-6) continue
          dir.normalize()

          tmpPos.copy(p1).add(p2).multiplyScalar(0.5)
          tmpQuat.setFromUnitVectors(up, dir)
          tmpScale.set(1, len, 1)
          tmpMat4.compose(tmpPos, tmpQuat, tmpScale)
          edgeMesh.setMatrixAt(k, tmpMat4)
        }
        edgeMesh.instanceMatrix.needsUpdate = true
        edgeGroup.add(edgeMesh)
        scene.add(edgeGroup)

        // UI elements
        const tip = document.getElementById('tip')
        const details = document.getElementById('details')
        const q = document.getElementById('q')
        const showEdges = document.getElementById('showEdges')
        const edgeCount = document.getElementById('edgeCount')
        const resetBtn = document.getElementById('reset')
        edgeCount.textContent = `(${validEdges.length} edges)`

        showEdges.addEventListener('change', () => {
          edgeGroup.visible = showEdges.checked
        })

        resetBtn.addEventListener('click', () => {
          camera.position.set(2, 2, 2)
          controls.reset()
        })

        const escapeHtml = (s) => String(s).replace(/[&<>\"]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[c]||c))

        const showDetails = (it) => {
          const loc = it.path ? `${it.path}:${it.line||1}` : ''
          details.style.display = 'block'
          details.innerHTML =
            `<h3>${escapeHtml(it.name||'')}</h3>` +
            `<div class="muted">${escapeHtml(it.kind||'')} · <code>${escapeHtml(it.family||'')}</code></div>` +
            (loc ? `<div style="margin-top:6px"><code>${escapeHtml(loc)}</code></div>` : '') +
            (it.snippet ? `<div style="margin-top:10px" class="muted">${escapeHtml(it.snippet)}</div>` : '')
        }

        // Raycasting for selection
        const raycaster = new THREE.Raycaster()
        const mouse = new THREE.Vector2()
        let selected = null

        container.addEventListener('click', (ev) => {
          mouse.x = (ev.clientX / window.innerWidth) * 2 - 1
          mouse.y = -(ev.clientY / window.innerHeight) * 2 + 1

          raycaster.setFromCamera(mouse, camera)
          const intersects = raycaster.intersectObjects(nodeMeshes)

          if (intersects.length > 0) {
            const idx = intersects[0].object.userData.index
            selected = idx
            showDetails(items[idx])

            // Highlight selected
            nodeMeshes.forEach((m, i) => {
              m.scale.setScalar(i === idx ? 2 : 1)
            })
          } else {
            selected = null
            details.style.display = 'none'
            nodeMeshes.forEach(m => m.scale.setScalar(1))
          }
        })

        // Hover tooltip
        container.addEventListener('mousemove', (ev) => {
          mouse.x = (ev.clientX / window.innerWidth) * 2 - 1
          mouse.y = -(ev.clientY / window.innerHeight) * 2 + 1

          raycaster.setFromCamera(mouse, camera)
          const intersects = raycaster.intersectObjects(nodeMeshes)

          if (intersects.length > 0) {
            const idx = intersects[0].object.userData.index
            tip.style.display = 'block'
            tip.style.left = (ev.clientX + 12) + 'px'
            tip.style.top = (ev.clientY + 12) + 'px'
            tip.textContent = items[idx].name
          } else {
            tip.style.display = 'none'
          }
        })

        // Search filtering
        q.addEventListener('input', () => {
          const query = q.value.trim().toLowerCase()
          nodeMeshes.forEach((m, i) => {
            const name = items[i].name?.toLowerCase() || ''
            m.visible = !query || name.includes(query)
          })
        })

        // Window resize
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight
          camera.updateProjectionMatrix()
          renderer.setSize(window.innerWidth, window.innerHeight)
        })

        // Animation loop
        function animate() {
          requestAnimationFrame(animate)
          controls.update()
          renderer.render(scene, camera)
        }
        animate()
      })()
    </script>
  </body>
</html>
