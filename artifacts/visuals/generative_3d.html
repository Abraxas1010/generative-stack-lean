<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Generative Stack — 3D Proof Map</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; overflow: hidden; background:#0b0f14; color:#e6eef7; font: 13px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      #ui { position: fixed; top: 12px; left: 12px; right: 12px; display:flex; gap: 10px; align-items: center; z-index: 10; }
      .panel { background: rgba(15,23,33,0.92); border: 1px solid #1c2a3a; border-radius: 10px; padding: 10px 12px; backdrop-filter: blur(6px); }
      input[type="text"]{ width: 360px; max-width: 60vw; background:#0b1320; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; outline:none; }
      label { user-select:none; }
      button { background:#132033; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; cursor:pointer; }
      button:hover { background:#182a42; }
      #tip { position: fixed; pointer-events:none; z-index: 20; padding: 6px 8px; border-radius: 8px; background: rgba(0,0,0,0.75); border:1px solid rgba(255,255,255,0.10); display:none; max-width: 56vw; }
      #details { position: fixed; right: 12px; bottom: 12px; width: min(520px, calc(100vw - 24px)); max-height: 45vh; overflow:auto; white-space: pre-wrap; }
      #details h3 { margin: 0 0 8px; font-size: 14px; }
      .muted { color:#b8c7d9; }
      .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
      a { color:#8ab4f8; text-decoration:none; }
      a:hover{ text-decoration:underline; }
      code { background:#0b1320; border:1px solid #24364a; border-radius: 6px; padding:1px 6px; }
      svg { display:block; width: 100vw; height: 100vh; }
      .edge { stroke: rgba(245, 248, 252, 0.50); stroke-width: 1.25; stroke-linecap: round; stroke-linejoin: round; vector-effect: non-scaling-stroke; }
      .node { stroke: rgba(255,255,255,0.10); stroke-width: 1.0; vector-effect: non-scaling-stroke; }
      .node.hit { stroke: rgba(255,255,255,0.85); stroke-width: 1.7; }
    </style>
  </head>
  <body>
    <div id="ui" class="row">
      <div class="panel row">
        <a href="../../index.html">&larr; index</a>
        <input id="q" type="text" placeholder="Search declarations (substring)..." />
        <label><input id="showEdges" type="checkbox" checked /> edges</label>
        <span id="edgeCount" class="muted"></span>
        <button id="reset">Reset View</button>
      </div>
      <div class="panel muted">Rotate: drag · Zoom: wheel · Select: click</div>
    </div>
    <div id="tip"></div>
    <div id="details" class="panel" style="display:none"></div>

    <svg id="svg" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet" role="img" aria-label="3D proof map (projected)">
      <g id="edges"></g>
      <g id="nodes"></g>
    </svg>

    <script src="./generative_proofs_data.js"></script>
    <script>
      ;(() => {
        const data = window.GENERATIVE_PROOFS || { items: [], edges: [] }
        const items = data.items || []
        const edges = data.edges || []

        const svg = document.getElementById('svg')
        const edgesG = document.getElementById('edges')
        const nodesG = document.getElementById('nodes')

        const tip = document.getElementById('tip')
        const details = document.getElementById('details')
        const q = document.getElementById('q')
        const showEdges = document.getElementById('showEdges')
        const edgeCount = document.getElementById('edgeCount')
        const resetBtn = document.getElementById('reset')

        edgeCount.textContent = `(${edges.length} edges)`

        const W = 1000
        const H = 700

        const colorForFamily = (fam) => {
          const map = {
            'LoF':'#6c5ce7',
            'Eigenform':'#e17055',
            'Lawvere':'#e94560',
            'Surreal':'#0984e3',
            'Combinator':'#fd79a8',
            'Ratchet':'#00b894',
            'Quantum':'#9b59b6',
            'HoTT':'#f39c12',
            'Bauer':'#e67e22',
            'Test':'#636e72'
          }
          return map[fam] || '#90a4ae'
        }

        const escapeHtml = (s) => String(s).replace(/[&<>\"]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[c]||c))
        const showDetails = (it) => {
          const loc = it.path ? `${it.path}:${it.line||1}` : ''
          details.style.display = 'block'
          details.innerHTML =
            `<h3>${escapeHtml(it.name||'')}</h3>` +
            `<div class="muted">${escapeHtml(it.kind||'')} · <code>${escapeHtml(it.family||'')}</code></div>` +
            (loc ? `<div style="margin-top:6px"><code>${escapeHtml(loc)}</code></div>` : '') +
            (it.snippet ? `<div style="margin-top:10px" class="muted">${escapeHtml(it.snippet)}</div>` : '')
        }

        const showTip = (sx, sy, text) => {
          tip.style.display = 'block'
          tip.style.left = (sx + 12) + 'px'
          tip.style.top = (sy + 12) + 'px'
          tip.textContent = text
        }
        const hideTip = () => { tip.style.display='none' }

        let selected = null
        let hover = null
        let query = ''

        const matchesQuery = (it) => {
          const ql = query.trim().toLowerCase()
          if (!ql) return true
          return String(it?.name ?? '').toLowerCase().includes(ql)
        }

        const cam = { yaw: 0.95, pitch: 0.62, zoom: 1.25 }

        const pos3 = items.map((it) => {
          const p = it?.pos3 ?? { x: 0.5, y: 0.5, z: 0.5 }
          return { x: (p.x - 0.5), y: (p.y - 0.5), z: (p.z - 0.5) }
        })

        const nodeEls = new Array(items.length)
        for (let i = 0; i < items.length; i++) {
          const it = items[i]
          const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle')
          c.setAttribute('class', 'node')
          c.setAttribute('r', '3.6')
          c.setAttribute('fill', colorForFamily(it?.family))
          c.dataset.idx = String(i)
          nodesG.appendChild(c)
          nodeEls[i] = c
        }

        const edgeEls = []
        for (const [i, j] of edges) {
          const p = document.createElementNS('http://www.w3.org/2000/svg', 'path')
          p.setAttribute('class', 'edge')
          p.setAttribute('fill', 'none')
          p.dataset.i = String(i)
          p.dataset.j = String(j)
          edgesG.appendChild(p)
          edgeEls.push(p)
        }

        const curvePath = (a, b) => {
          const dx = b.x - a.x
          const dy = b.y - a.y
          const d = Math.hypot(dx, dy)
          if (d < 1e-6) return `M ${a.x} ${a.y} L ${b.x} ${b.y}`
          const nx = -dy / d
          const ny = dx / d
          const bend = Math.max(10, Math.min(28, 0.75 * d + 10))
          const cx = (a.x + b.x) / 2 + nx * bend
          const cy = (a.y + b.y) / 2 + ny * bend
          return `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`
        }

        const project = (p) => {
          const cy = Math.cos(cam.yaw), sy = Math.sin(cam.yaw)
          const cx = Math.cos(cam.pitch), sx = Math.sin(cam.pitch)

          const x1 = p.x * cy + p.z * sy
          const z1 = -p.x * sy + p.z * cy
          const y2 = p.y * cx - z1 * sx
          const z2 = p.y * sx + z1 * cx

          const scale = 860 * cam.zoom
          const x = (W / 2) + x1 * scale
          const y = (H / 2) - y2 * scale
          return { x, y, z: z2 }
        }

        let raf = null
        const requestRender = () => {
          if (raf) return
          raf = requestAnimationFrame(() => { raf = null; render() })
        }

        const render = () => {
          const ql = query.trim().toLowerCase()
          const filtering = Boolean(ql)

          const proj = new Array(items.length)
          for (let i = 0; i < items.length; i++) proj[i] = project(pos3[i])

          const show = showEdges.checked
          for (const el of edgeEls) {
            if (!show) {
              el.setAttribute('display', 'none')
              continue
            }
            el.setAttribute('display', 'inline')
            const i = Number(el.dataset.i)
            const j = Number(el.dataset.j)
            const a = proj[i], b = proj[j]
            el.setAttribute('d', curvePath(a, b))
            if (!filtering) {
              el.setAttribute('opacity', '0.50')
            } else {
              const ok = matchesQuery(items[i]) && matchesQuery(items[j])
              el.setAttribute('opacity', ok ? '0.70' : '0.06')
            }
          }

          for (let i = 0; i < items.length; i++) {
            const it = items[i]
            const el = nodeEls[i]
            const p = proj[i]
            const depth = p.z

            const hit = (i === selected) || (i === hover)
            const match = !filtering || matchesQuery(it)

            const depthBoost = 1 + 0.55 * depth
            const base = 3.4 * Math.max(0.65, Math.min(1.65, depthBoost))
            const r = hit ? base * 1.65 : match ? base : base * 0.85

            el.classList.toggle('hit', hit)
            el.setAttribute('cx', String(p.x))
            el.setAttribute('cy', String(p.y))
            el.setAttribute('r', String(r))
            el.setAttribute('opacity', match ? '0.95' : '0.12')
          }
        }

        let dragging = null
        svg.addEventListener('mousedown', (ev) => {
          const target = ev.target
          if (target && target.classList && target.classList.contains('node')) return
          dragging = { x: ev.clientX, y: ev.clientY, yaw: cam.yaw, pitch: cam.pitch }
        })
        window.addEventListener('mousemove', (ev) => {
          if (!dragging) return
          const dx = (ev.clientX - dragging.x)
          const dy = (ev.clientY - dragging.y)
          cam.yaw = dragging.yaw + dx * 0.006
          cam.pitch = Math.max(-1.45, Math.min(1.45, dragging.pitch + dy * 0.006))
          requestRender()
        })
        window.addEventListener('mouseup', () => { dragging = null })

        svg.addEventListener('wheel', (ev) => {
          ev.preventDefault()
          const delta = Math.sign(ev.deltaY)
          const factor = delta > 0 ? 0.90 : 1.11
          cam.zoom = Math.max(0.35, Math.min(6.0, cam.zoom * factor))
          requestRender()
        }, { passive: false })

        const hitTest = (sx, sy) => {
          const mx = (sx / svg.clientWidth) * W
          const my = (sy / svg.clientHeight) * H
          const ql = query.trim().toLowerCase()
          const filtering = Boolean(ql)
          let best = null
          let bestD = Infinity
          const r2 = 12 * 12

          for (let i = 0; i < items.length; i++) {
            if (filtering && !matchesQuery(items[i])) continue
            const el = nodeEls[i]
            const cx = Number(el.getAttribute('cx') || 0)
            const cy = Number(el.getAttribute('cy') || 0)
            const d = (cx - mx) * (cx - mx) + (cy - my) * (cy - my)
            if (d < bestD) { bestD = d; best = i }
          }
          if (best !== null && bestD <= r2) return best
          return null
        }

        svg.addEventListener('mousemove', (ev) => {
          const h = hitTest(ev.offsetX, ev.offsetY)
          hover = h
          if (hover !== null) showTip(ev.clientX, ev.clientY, items[hover]?.name ?? '')
          else hideTip()
          requestRender()
        })

        svg.addEventListener('click', (ev) => {
          const h = hitTest(ev.offsetX, ev.offsetY)
          selected = h
          if (selected !== null) showDetails(items[selected])
          else details.style.display = 'none'
          requestRender()
        })

        q.addEventListener('input', () => {
          query = q.value
          requestRender()
        })
        showEdges.addEventListener('change', requestRender)

        resetBtn.addEventListener('click', () => {
          cam.yaw = 0.95
          cam.pitch = 0.62
          cam.zoom = 1.25
          requestRender()
        })

        render()
      })()
    </script>
  </body>
</html>
