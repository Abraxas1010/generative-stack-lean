<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Generative Stack — 2D Proof Map</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; overflow: hidden; background:#0b0f14; color:#e6eef7; font: 13px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      #ui { position: fixed; top: 12px; left: 12px; right: 12px; display:flex; gap: 10px; align-items: center; z-index: 10; }
      .panel { background: rgba(15,23,33,0.92); border: 1px solid #1c2a3a; border-radius: 10px; padding: 10px 12px; backdrop-filter: blur(6px); }
      input[type="text"]{ width: 360px; max-width: 60vw; background:#0b1320; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; outline:none; }
      label { user-select:none; }
      button { background:#132033; color:#e6eef7; border:1px solid #24364a; border-radius: 8px; padding: 7px 10px; cursor:pointer; }
      button:hover { background:#182a42; }
      #tip { position: fixed; pointer-events:none; z-index: 20; padding: 6px 8px; border-radius: 8px; background: rgba(0,0,0,0.75); border:1px solid rgba(255,255,255,0.10); display:none; max-width: 56vw; }
      #details { position: fixed; right: 12px; bottom: 12px; width: min(520px, calc(100vw - 24px)); max-height: 45vh; overflow:auto; white-space: pre-wrap; }
      #details h3 { margin: 0 0 8px; font-size: 14px; }
      .muted { color:#b8c7d9; }
      .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
      a { color:#8ab4f8; text-decoration:none; }
      a:hover{ text-decoration:underline; }
      code { background:#0b1320; border:1px solid #24364a; border-radius: 6px; padding:1px 6px; }
      svg { display:block; width: 100vw; height: 100vh; }
      .edge { stroke: rgba(245, 248, 252, 0.55); stroke-width: 1.35; stroke-linecap: round; stroke-linejoin: round; vector-effect: non-scaling-stroke; }
      .node { stroke: rgba(255,255,255,0.12); stroke-width: 1.0; vector-effect: non-scaling-stroke; }
      .node.hit { stroke: rgba(255,255,255,0.85); stroke-width: 1.7; }
    </style>
  </head>
  <body>
    <div id="ui" class="row">
      <div class="panel row">
        <a href="../../index.html">&larr; index</a>
        <input id="q" type="text" placeholder="Search declarations (substring)..." />
        <label><input id="showEdges" type="checkbox" checked /> edges</label>
        <span id="edgeCount" class="muted"></span>
        <button id="fit">Fit</button>
      </div>
      <div class="panel muted">Pan: drag · Zoom: wheel · Select: click</div>
    </div>
    <div id="tip"></div>
    <div id="details" class="panel" style="display:none"></div>

    <svg id="svg" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet" role="img" aria-label="2D proof map">
      <g id="viewport">
        <g id="edges"></g>
        <g id="nodes"></g>
      </g>
    </svg>

    <script src="./generative_proofs_data.js"></script>
    <script>
      ;(() => {
        const data = window.GENERATIVE_PROOFS || { items: [], edges: [] }
        const items = data.items || []
        const edges = data.edges || []

        const svg = document.getElementById('svg')
        const viewport = document.getElementById('viewport')
        const edgesG = document.getElementById('edges')
        const nodesG = document.getElementById('nodes')

        const tip = document.getElementById('tip')
        const details = document.getElementById('details')
        const q = document.getElementById('q')
        const showEdges = document.getElementById('showEdges')
        const edgeCount = document.getElementById('edgeCount')
        const fitBtn = document.getElementById('fit')

        edgeCount.textContent = `(${edges.length} edges)`

        const W = 1000
        const H = 700
        const M = 36

        const colorForFamily = (fam) => {
          const map = {
            'LoF':'#6c5ce7',
            'Eigenform':'#e17055',
            'Lawvere':'#e94560',
            'Surreal':'#0984e3',
            'Combinator':'#fd79a8',
            'Ratchet':'#00b894',
            'Quantum':'#9b59b6',
            'HoTT':'#f39c12',
            'Bauer':'#e67e22',
            'Test':'#636e72'
          }
          return map[fam] || '#90a4ae'
        }

        const toWorld = (p) => {
          const x = M + (p?.x ?? 0.5) * (W - 2*M)
          const y = M + (1 - (p?.y ?? 0.5)) * (H - 2*M)
          return { x, y }
        }

        let selected = null
        let hover = null
        let query = ''

        const view = { panX: 0, panY: 0, scale: 1 }
        const setTransform = () => {
          viewport.setAttribute('transform', `translate(${view.panX},${view.panY}) scale(${view.scale})`)
        }
        setTransform()

        const escapeHtml = (s) => String(s).replace(/[&<>\"]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[c]||c))
        const showDetails = (it) => {
          const loc = it.path ? `${it.path}:${it.line||1}` : ''
          details.style.display = 'block'
          details.innerHTML =
            `<h3>${escapeHtml(it.name||'')}</h3>` +
            `<div class="muted">${escapeHtml(it.kind||'')} · <code>${escapeHtml(it.family||'')}</code></div>` +
            (loc ? `<div style="margin-top:6px"><code>${escapeHtml(loc)}</code></div>` : '') +
            (it.snippet ? `<div style="margin-top:10px" class="muted">${escapeHtml(it.snippet)}</div>` : '')
        }

        const showTip = (sx, sy, text) => {
          tip.style.display = 'block'
          tip.style.left = (sx + 12) + 'px'
          tip.style.top = (sy + 12) + 'px'
          tip.textContent = text
        }
        const hideTip = () => { tip.style.display='none' }

        const matchesQuery = (it) => {
          const ql = query.trim().toLowerCase()
          if (!ql) return true
          return String(it?.name ?? '').toLowerCase().includes(ql)
        }

        const nodeEls = new Array(items.length)
        const worldPos = new Array(items.length)

        for (let i = 0; i < items.length; i++) {
          const it = items[i]
          worldPos[i] = toWorld(it?.pos)
          const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle')
          c.setAttribute('class', 'node')
          c.setAttribute('r', '2.2')
          c.setAttribute('cx', String(worldPos[i].x))
          c.setAttribute('cy', String(worldPos[i].y))
          c.setAttribute('fill', colorForFamily(it?.family))
          c.dataset.idx = String(i)
          nodesG.appendChild(c)
          nodeEls[i] = c
        }

        const edgeEls = []
        const curvePath = (a, b) => {
          const dx = b.x - a.x
          const dy = b.y - a.y
          const d = Math.hypot(dx, dy)
          if (d < 1e-6) return `M ${a.x} ${a.y} L ${b.x} ${b.y}`
          const nx = -dy / d
          const ny = dx / d
          const bend = Math.max(10, Math.min(28, 0.75 * d + 10))
          const cx = (a.x + b.x) / 2 + nx * bend
          const cy = (a.y + b.y) / 2 + ny * bend
          return `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`
        }

        for (const [i, j] of edges) {
          const a = worldPos[i]
          const b = worldPos[j]
          if (!a || !b) continue
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
          path.setAttribute('class', 'edge')
          path.setAttribute('fill', 'none')
          path.setAttribute('d', curvePath(a, b))
          path.dataset.i = String(i)
          path.dataset.j = String(j)
          edgesG.appendChild(path)
          edgeEls.push(path)
        }

        const applyStyles = () => {
          const ql = query.trim().toLowerCase()
          const filtering = Boolean(ql)

          for (let i = 0; i < items.length; i++) {
            const it = items[i]
            const el = nodeEls[i]
            const hit = (i === selected) || (i === hover)
            const match = !filtering || matchesQuery(it)
            el.classList.toggle('hit', hit)
            el.setAttribute('opacity', match ? '0.95' : '0.12')
            el.setAttribute('r', hit ? '5.2' : match ? '2.2' : '1.8')
          }

          const show = showEdges.checked
          for (const el of edgeEls) {
            if (!show) {
              el.setAttribute('display', 'none')
              continue
            }
            el.setAttribute('display', 'inline')
            if (!filtering) {
              el.setAttribute('opacity', '0.55')
              continue
            }
            const i = Number(el.dataset.i)
            const j = Number(el.dataset.j)
            const ok = matchesQuery(items[i]) && matchesQuery(items[j])
            el.setAttribute('opacity', ok ? '0.75' : '0.06')
          }
        }

        // Pan/zoom
        let dragging = null
        svg.addEventListener('mousedown', (ev) => {
          const target = ev.target
          if (target && target.classList && target.classList.contains('node')) return
          dragging = { x: ev.clientX, y: ev.clientY, panX: view.panX, panY: view.panY }
        })
        window.addEventListener('mousemove', (ev) => {
          if (!dragging) return
          view.panX = dragging.panX + (ev.clientX - dragging.x)
          view.panY = dragging.panY + (ev.clientY - dragging.y)
          setTransform()
        })
        window.addEventListener('mouseup', () => { dragging = null })

        svg.addEventListener('wheel', (ev) => {
          ev.preventDefault()
          const delta = Math.sign(ev.deltaY)
          const factor = delta > 0 ? 0.90 : 1.11
          const next = Math.max(0.2, Math.min(8.0, view.scale * factor))
          const mx = (ev.offsetX / svg.clientWidth) * W
          const my = (ev.offsetY / svg.clientHeight) * H
          const wx = (mx - view.panX) / view.scale
          const wy = (my - view.panY) / view.scale
          view.scale = next
          view.panX = mx - wx * view.scale
          view.panY = my - wy * view.scale
          setTransform()
        }, { passive: false })

        const hitTest = (sx, sy) => {
          const mx = (sx / svg.clientWidth) * W
          const my = (sy / svg.clientHeight) * H
          const wx = (mx - view.panX) / view.scale
          const wy = (my - view.panY) / view.scale
          let best = null
          let bestD = Infinity
          const r2 = 10 * 10
          for (let i = 0; i < items.length; i++) {
            const p = worldPos[i]
            const d = (p.x - wx) * (p.x - wx) + (p.y - wy) * (p.y - wy)
            if (d < bestD) { bestD = d; best = i }
          }
          if (best !== null && bestD <= r2) return best
          return null
        }

        svg.addEventListener('mousemove', (ev) => {
          const h = hitTest(ev.offsetX, ev.offsetY)
          hover = h
          if (hover !== null) showTip(ev.clientX, ev.clientY, items[hover]?.name ?? '')
          else hideTip()
          applyStyles()
        })

        svg.addEventListener('click', (ev) => {
          const h = hitTest(ev.offsetX, ev.offsetY)
          selected = h
          if (selected !== null) showDetails(items[selected])
          else details.style.display = 'none'
          applyStyles()
        })

        q.addEventListener('input', () => {
          query = q.value
          applyStyles()
        })
        showEdges.addEventListener('change', applyStyles)

        const fit = () => {
          view.panX = 0
          view.panY = 0
          view.scale = 1
          setTransform()
        }
        fitBtn.addEventListener('click', fit)

        applyStyles()
      })()
    </script>
  </body>
</html>
